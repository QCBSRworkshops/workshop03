[["index.html", "Atelier 3: Introduction à ggplot2 Série d’ateliers R du CSBQ Préface 0.1 Code de conduite 0.2 Contributeurs et contributrices 0.3 Contribuez à la série!", " Atelier 3: Introduction à ggplot2 Série d’ateliers R du CSBQ Développé et entretenu par les contributeurs et les contributrices de la Série d’ateliers R du CSBQ1. 2021-11-08 15:03:46 Préface La Série d’ateliers R du CSBQ est une série de 10 ateliers qui guide les participants à travers les étapes nécessaires à l’utilisation de R pour un large éventail d’analyses statistiques pertinentes pour la recherche en biologie et en écologie. Ces ateliers en accès libre ont été créés par des membres du CSBQ, à la fois pour les membres du CSBQ et pour la communauté au sens large. Le contenu de cet atelier a été revu par plusieurs membres du CSBQ. Si vous souhaitez suggérer des modifications, veuillez contacter les coordinateurs de la série actuelle, dont la liste figure sur la page principale de Github 0.1 Code de conduite La Série d’ateliers R du CSBQ et le Symposium R du CSBQ sont des lieux dédiés à fournir un environnement accueillant et favorable à toutes les personnes, indépendamment de leurs origines ou de leur identité. Les participants, les présentateurs et les organisateurs de la série d’ateliers et d’autres activités connexes acceptent le présent code de conduite lorsqu’ils assistent à des activités liées aux ateliers. Nous ne tolérons pas les comportements irrespectueux ou qui excluent, intimident ou gênent les autres. Nous ne tolérons pas la discrimination ou le harcèlement fondés sur des caractéristiques telles que, mais sans s’y limiter, l’identité et l’expression du genre, l’orientation sexuelle, le handicap, l’apparence physique, la taille du corps, la citoyenneté, la nationalité, les origines ethniques ou sociales, la grossesse, le statut familial, les informations génétiques, la religion ou les convictions (ou l’absence de celles-ci), l’appartenance à une minorité nationale, la propriété, l’âge, l’éducation, le statut socio-économique, les choix techniques et le niveau d’expérience. Il s’applique à tous les espaces gérés par l’atelier ou affiliés à celui-ci, y compris, mais sans s’y limiter, les ateliers, les listes de diffusion et les forums en ligne tels que GitHub, Slack et Twitter. 0.1.1 Comportement attendu Tous les participants sont tenus de faire preuve de respect et de courtoisie envers les autres. Toutes les interactions doivent être professionnelles, quelle que soit la plateforme utilisée : en ligne ou en personne. Afin de favoriser un environnement d’apprentissage positif et professionnel, nous encourageons les types de comportements suivants dans tous les événements et plates-formes des ateliers : Utiliser un langage accueillant et inclusif ; Respecter les différents points de vue et expériences ; Accepter avec grâce les critiques constructives ; Se concentrer sur ce qui est le mieux pour la communauté ; Faire preuve de courtoisie et de respect envers les autres membres de la communauté. 0.1.2 Comportements inacceptables Voici quelques exemples de comportements inacceptables de la part des participants à tout événement ou plateforme d’atelier : les commentaires écrits ou verbaux qui ont pour effet d’exclure des personnes sur la base de leur appartenance à un groupe spécifique ; faire craindre à quelqu’un pour sa sécurité, par exemple en le harcelant ou en l’intimidant ; des menaces ou des propos violents dirigés contre une autre personne ; l’affichage d’images sexuelles ou violentes ; l’attention sexuelle non désirée ; les contacts physiques non consensuels ou non désirés ; des insultes ou des rabais ; les blagues sexistes, racistes, homophobes, transphobes, incapables ou d’exclusion ; l’incitation à la violence, au suicide ou à l’automutilation ; la poursuite de l’interaction (y compris la photographie ou l’enregistrement) avec une personne après qu’on - lui a demandé d’arrêter ; la publication d’une communication privée sans consentement. 0.2 Contributeurs et contributrices Cet atelier a été développé à l’origine par Xavier Giroux-Bougard, Maxwell Farrell, Amanda Winegardner, Étienne Low-Decarie et Monica Granados. Depuis 2014, plusieurs membres du CSBQ ont contribué à développer et à mettre à jour cet atelier de manière régulière et collaborative, dans le cadre de la bourse d’apprentissage et de développement (Learning and Development Award) du Centre québécois des sciences de la biodiversité. 2022 - 2021 - 2020 2019 - 2018 - 2017 2016 - 2015 - 2014 Linley Sherin Marie-Hélène Brice Xavier Giroux-Bougard Katherine Hébert Willian Vieira Maxwell Farrell Jake Lawlor Rémi Maglione Amanda Winegardner Marie-Hélène Brice Pedro Henrique P. Braga Étienne Low-Decarie Kevin Cazelles Alexis Carteron Monica Granados Katherine Hébert 0.3 Contribuez à la série! La série d’ateliers R du CSBQ dépend sur les contributions des membres étudiants diplômés, postdoctoraux et professionnels de la recherche du CSBQ pour développer et présenter les ateliers. Nous sommes toujours à la recherche de contributeurs et contributrices pour amélorier le matériel et pour instruire les ateliers. Pour plus d’informations, nous vous invitons à consulter notre Protocole pour la présentation et le development. Si vous êtes intéressé(e)s à contribuer à la série d’ateliers, contactez-nous! Si vous trouvez des erreurs ou des incohérences, ou si vous souhaitez faire une suggestion, que ce soit sur la forme ou le contenu de ce matériel, vous êtes invités à ouvrir un numéro. Vous pouvez suivre ces étapes simples pour créer un nouveau numéro. La Série d’ateliers R du CSBQ fait partie du Centre de la science de la biodiversité du Québec, et est maintenue par les coordonnateurs et les coordonnatrices de la série, et les membres étudiants diplômés, postdoctoraux et professionnels de la recherche. La liste des contributeurs et des contributrices de cet atelier sont accessiblesici↩︎ "],["préparez-vous-pour-cet-atelier.html", "Chapitre 1 Préparez-vous pour cet atelier", " Chapitre 1 Préparez-vous pour cet atelier Tout le matériel de l’atelier se trouve sur github.com/QCBSRworkshops/workshop03. Cela inclut un script R qui rassemble tous les morceaux de code présentés dans ce livre. Vous devriez vous assurer que vous avez téléchargé, installé et chargé les librairies R suivantes: gridExtra ggplot2 ggsignif ggdendro maps mapproj RColorBrewer reshape2 GGally patchwork plotly palmerpenguins Pour les installer du CRAN, roulez le code suivant: # Installez les librairies requises install.packages(&quot;gridExtra&quot;) install.packages(&quot;ggplot2&quot;) install.packages(&quot;ggsignif&quot;) install.packages(&quot;ggdendro&quot;) install.packages(&quot;maps&quot;) install.packages(&quot;mapproj&quot;) install.packages(&quot;RColorBrewer&quot;) install.packages(&quot;reshape2&quot;) install.packages(&quot;GGally&quot;) install.packages(&quot;patchwork&quot;) # install.packages(&#39;plotly&#39;) install.packages(&quot;palmerpenguins&quot;) Ensuite, on doit charger les librairies avec le code suivant: # Load the required packages library(gridExtra) library(ggplot2) library(ggsignif) library(ggdendro) library(maps) library(mapproj) library(RColorBrewer) library(reshape2) library(GGally) library(patchwork) # library(plotly) library(palmerpenguins) "],["objectifs-dapprentissage.html", "Chapitre 2 Objectifs d’apprentissage 2.1 Plan de l’atelier", " Chapitre 2 Objectifs d’apprentissage Dans cet atelier, nous allons : 1. Apprendre les bases de la visualisation de données avec R. 2. Apprendre comment trouver des librairies et des ressources pour répondre à vos besoins. 3. Inspirer la créativité dans la science ! 4. Développer une compréhension du design pour une communication visuelle efficace. 2.1 Plan de l’atelier Aujourd’hui, nous allons vous présenter les bases de ggplot2 afin que vous ayez les outils nécessaires pour l’utiliser dans vos propres projets. Nous allons aborder les sujets suivants : 1. La visualisation en science 2. Mécanique de ggplot2 : les bases 3. Le mapping esthétique 4. Perfectionnement 5. Sauvegarder vos graphiques 6. Conclusion "],["pourquoi-visualiser-des-données.html", "Chapitre 3 Pourquoi visualiser des données ?", " Chapitre 3 Pourquoi visualiser des données ? Avant de voir comment nous pouvons visualiser nos données, commençons par répondre à la question pourquoi la visualisation des données est importante. La visualisation peut être utile (voire essentielle) pour représenter les résultats d’analyses statistiques, pour formuler des hypothèses et résumer la théorie, pour explorer vos données afin de mieux les comprendre via une analyse exploratoire ou la détection de valeurs aberrantes, et plus encore. Plus important encore, la visualisation est surtout efficace pour communiquer et rapporter vos résultats lorsqu’elle est faite : De manière claire (en utilisant de bons principes de design) ; Avec précision et exactitude (un graphique vaut 1000 mots) ; De manière efficace. Voici un exemple de visualisation inéfficace : Figure 3.1: An example of an ineffective visualization. Quels sont des défauts de cette figure? Essayez de répondre par vous-même à cette question: que pensez-vous que cette figure essaie de communiquer et est-ce qu’elle y parvient? Comment cette image pourrait-elle être améliorée ? Indices: Pourquoi cette image est-elle en 3D? Quels éléments attirent votre attention? Comment un diagramme circulaire communique-t-il visuellement l’information? Pour vous assurer que vous communiquez efficacement, voici quelques questions importantes à vous poser lorsque vous visualisez vos données: Que voulez-vous communiquer? Qui est votre public? Quelle est la meilleure façon de visualiser votre message? Une règle générale : restez simple - utilisez moins d’encre! "],["pourquoi-utiliser-r.html", "Chapitre 4 Pourquoi utiliser R? 4.1 Reproductibilité 4.2 Puissantes fonctionnalités", " Chapitre 4 Pourquoi utiliser R? Que vous effectuiez des statistiques descriptives (e.g. Excel), des analyses plus avancées (e.g. SAS, JMP, SPSS) ou des graphiques et des tableaux (e.g. Sigmaplot, Excel), il est facile de se perdre dans le flux de travail lorsqu’on utilise plusieurs logiciels. Ceci s’avère particulièrement problématique lorsqu’on doit importer ou exporter des données pour effectuer une tâche en aval. À chaque opération, on augmente le risque d’introduire des erreurs dans les données ou de perdre de vue le “bon” fichier de données. Le langage statistique R fournit une solution à ce problème en regroupant tous les outils nécessaires pour manipuler des données, effectuer des analyses statistiques et produire des graphiques sous un seul logiciel. En regroupant notre flux de travail sous le même toit avec R, on réduit la probabilité de faire des erreurs et on rend notre flux de travail beaucoup plus compréhensible et reproductible. Tout ceci en vaut grandement l’effort! Au lieu d’utiliser une suite de logiciels… Vous pouvez utiliser R pour générer des visualisations de données reproductibles, le tout dans un seul programme, R Studio. Quel est l’avantage d’utiliser R pour la visualisation des données? 4.1 Reproductibilité L’une des principales raisons d’utiliser R pour la visualisation est qu’elle rend votre graphique entièrement reproductible. Vous pouvez annoter votre script, ajouter des informations supplémentaires (ex. titres, étiquettes, légendes, etc.) et maintenir le code pour toutes les versions de vos figures afin de toujours savoir comment elles ont été produites. La science reproductible demande des efforts, mais elle devient rapidement une norme de travail et constitue un investissement qui vous fera gagner beaucoup de temps, à vous et à vos collaborateurs, à long terme! 4.2 Puissantes fonctionnalités Une autre raison d’utiliser R concerne ses puissantes fonctionnalités, comme ggplot2. ggplot2 est la librairie la plus flexible et la plus complète disponible pour la visualisation avancée de données en R. Cette librairie a été créée pour R par Hadley Wickham sur la base de la Grammar of Graphics de Leland Wilkinson. Figure 4.1: Le code source de la librairie ggplot2 est hébergé sur GitHub: github.com/hadley/ggplot2. Dans cet atelier, nous nous concentrons uniquement sur ggplot2, mais il y a beaucoup d’autres outils et fonctions (https://insileco.github.io/wiki/rgraphpkgs/) qui peuvent être utilisés pour la visualisation (par exemple, base R, plotly, sjPlot, mapview, igraph). Voici quelques exemples de graphiques que vous pouvez faire avec la base R, ou avec ggplot2. Figure 4.2: Un petit aperçu de figures que vous pouvez réaliser avec base R (row 1) et ggplot2 (row 2), basées sur la librairie de données palmerpenguins. Nous nous concentrons sur ggplot2 en raison de sa versatilité. 1. ggplot2 vous permet de créer de beaux graphiques personnalisables; 2. ggplot2 implémente la grammaire des graphiques, qui est un système fiable pour construire des graphiques. 3. Il existe de nombreuses extensions pour ajouter encore plus de fonctionnalités à ggplot2, ce qui permet une multitude d’applications. "],["la-grammaire-des-graphiques-gg.html", "Chapitre 5 La grammaire des graphiques (GG) 5.1 Les bases de GG 5.2 Les couches de GG", " Chapitre 5 La grammaire des graphiques (GG) 5.1 Les bases de GG Commençons par les bases! La librairie ggplot2 est basée sur la Grammaire des Graphiques (GG), qui est un cadre pour la visualisation de données qui décompose chaque élément d’un graphique en composants individuels, créant ainsi des couches distinctes. En utilisant le système GG, nous pouvons construire des graphiques étape par étape pour des résultats flexibles et personnalisables. Les couches GG ont des noms spécifiques que vous verrez tout au long de l’atelier: Figure 5.1: Image adaptée de The Grammar of Graphics. Pour créer un ggplot, les couches de données et de mapping sont des exigences de base, tandis que les autres couches sont destinées à une configuration supplémentaire. Les couches ‘non requises’ sont toujours importantes à considérer, mais vous serez en mesure de générer un graphique de base sans celles-ci. Figure 5.2: Conditions de base pour générer un `ggplot’. 5.2 Les couches de GG 5.2.1 Descriptions de couches courantes Voici une décomposition de chaque couche Grammaire des Graphiques et des arguments courants pour chacune d’elles qui peut vous servir de référence: Données : vos données, dans un format tidy, fourniront les ingrédients de votre graphique. utilisez les techniques dplyr pour préparer les données pour un format optimal pour la visualisation. En général, cela signifie que vous devez avoir une rangée pour chaque observation que vous voulez visualiser. Esthétique (aes), pour rendre les données visibles x, y: position le long des axes x et y colour: la couleur des géométries selon les données fill: la couleur intérieure des géométries group: à quel groupe appartient une géométrie shape: la forme des points linetype: le type de ligne utilisé (pleine, pointillée, etc.) size: la taille des points ou des lignes alpha: la transparence des géométries Objets géométriques (geoms) geom_point() : diagramme de dispersion geom_line() : lignes reliant des points par une valeur croissante de x geom_path() : lignes reliant des points dans l’ordre d’apparition geom_boxplot() : diagramme en boîte (boxplot) pour les variables catégoriques geom_bar() : diagrammes à barres pour un axe des x catégorique geom_histogram() : histogramme pour l’axe des x continu geom_violin() : kernel de distribution de la dispersion des données geom_smooth() : ligne de lissage en fonction des données Facettes facet_wrap() ou facet_grid() pour de petits multiples Statistiques similaire aux géométries, mais issue de calcul sur les données indique les moyennes, les comptages et autres résumés statistiques des données Coordonnées - ajustement des données sur une page coord_cartesian pour fixer des limites coord_polar pour les graphiques circulaires coord_map pour différentes projections cartographiques Thèmes Effets visuels globaux par défaut polices, couleurs, formes, contours 5.2.2 Comment assembler ces couches Essayons de mettre ces couches ensemble! Voici les étapes de base pour construire une figure. Vous pouvez vous référer à ces étapes tout au long de l’atelier si vous voulez de l’aide ! Créer un objet graphique simple : plot.object &lt;- ggplot() Ajouter des couches géométriques : plot.object &lt;- plot.object + geom_*() Ajouter des couches d’apparence : plot.object &lt;- plot.object + coord_*() + theme() Répétez l’étape 2-3 jusqu’à ce que vous soyez satisfait, puis imprimez : plot.object ou print(plot.object). Nous reviendrons sur cette syntaxe au chapitre 6.4, où nous aborderons les couches de manière plus approfondie! "],["les-bases-de-la-visualisation-de-données.html", "Chapitre 6 Les bases de la visualisation de données 6.1 Le jeu de données: palmerpenguins 6.2 Questions scientifiques à propos des pingouins 6.3 Explorer la structure des données 6.4 La dynamique ggplot() par couches 6.5 Défi 1", " Chapitre 6 Les bases de la visualisation de données 6.1 Le jeu de données: palmerpenguins Essayons maintenant de visualiser des données! Nous allons utiliser le jeu de données palmerpenguins. Figure 6.1: Art par Allison Horst. Ce jeu de données contient des mesures morphologiques pour trois espèces de pingouins observées sur trois îles de l’archipel Palmer, en Antarctique. Ces données ont été recueillies de 2007 à 2009 par la Dre Kristen Gorman dans le cadre du programme de recherche écologique à long terme de la station Palmer, qui fait partie du réseau américain de recherche écologique à long terme. Figure 6.2: Artwork by Allison Horst. This dataset is often used to replace the iris dataset, which has some problems for teaching data science, including its ties to eugenics (more on this at armchairecology.blog/iris-dataset). Cet ensemble de données a également été utilisé pour un défi TidyTuesday, montrant les nombreuses possibilités de visualisation créative de l’ensemble de données. Par exemple : ceci, and ceci. Regardons les variables de l’ensemble de données des pingouins : str(penguins) # regardons les données des pingouins ! ## tibble [344 × 8] (S3: tbl_df/tbl/data.frame) ## $ species : Factor w/ 3 levels &quot;Adelie&quot;,&quot;Chinstrap&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## $ island : Factor w/ 3 levels &quot;Biscoe&quot;,&quot;Dream&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... ## $ bill_length_mm : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ... ## $ bill_depth_mm : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ... ## $ flipper_length_mm: int [1:344] 181 186 195 NA 193 190 181 195 193 190 ... ## $ body_mass_g : int [1:344] 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ... ## $ sex : Factor w/ 2 levels &quot;female&quot;,&quot;male&quot;: 2 1 1 NA 1 2 1 2 NA NA ... ## $ year : int [1:344] 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ... Figure 6.3: Art par Allison Horst. Notez que l’espèce, l’île et le sexe (species, island, et sex) sont des facteurs, qui seront importantes pour regrouper les données avec des couleurs, des formes, etc. dans ggplot2. Il y a ensuite 2 variables numériques (mesures du bec représentées dans l’image), et deux variables entières (longueur des nageoires et masse corporelle). Les données ont également une petite composante temporelle (year), s’étendant de 2007 à 2009. La librairie ggplot2 requiert de préparer les données comme un objet de la classe ‘data.frame’ ou ‘tibble’ (commun dans l’univers tidyverse). class(penguins) # vérifier la classe des données pour s&#39;assurer qu&#39;il s&#39;agit d&#39;un data.frame ou d&#39;un tibble pour ggplot2 ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; # vous pouvez transformer un ensemble de données en tibble # via la fonction as_tibble() si nécessaire peng &lt;- # tibble::as_tibble(penguins) class(peng) ♻ Rappel de l’atelier 2 - Charger et manipuler des données: Les graphiques plus complexes dans les ggplot2 nécessitent que les données soient en format long. 6.2 Questions scientifiques à propos des pingouins Quelles sont quelques questions scientifiques auxquelles nous pourrions vouloir répondre avec ce jeu de données? Voici quelques exemples: Y a-t-il une relation entre la longueur et la profondeur des becs ? Est-ce que la taille des becs et des nageoires varient ensemble ? Comment ces mesures sont-elles réparties entre les 3 espèces ? Comment pouvons-nous répondre graphiquement à ces questions avec ggplot2? 6.3 Explorer la structure des données Si nous voulons avoir un aperçu général de nos données, nous pouvons commencer par utiliser la fonction ggpairs() du paquet GGally (que nous avons chargé et installé au début de l’atelier). Cela nous permettra d’examiner les relations préliminaires, avant de les explorer plus en détail. ## Voir un aperçu général de nos données avec plusieurs ## types de graphiques ggpairs(penguins, aes(colour = species), progress = FALSE) + theme_bw() On peut déjà voir certains regroupements d’espèces entre la longueur et la profondeur du bec, la longueur des nageoires et la masse corporelle. Lors de la visualisation, il faudra garder à l’esprit que la différenciation des espèces peut être importante. Remarquez-vous ces regroupements? Nous devrions explorer comment certaines de ces données sont structurées par espèce! # Explorons comment nos données sont structurées par espèce ggplot(data = penguins, # Données aes(x = bill_length_mm, # Valeurs X y = bill_depth_mm, # Valeurs Y col = species)) + # Esthétique (mettre une couleur par espèce) geom_point(size = 5, alpha = 0.8) + # Points geom_smooth(method = &quot;lm&quot;) + # Régression linéaire labs(title = &quot;Relationship between bill length and depth\\nfor different penguin species&quot;, # Title x = &quot;Bill length (mm)&quot;, # titre de l&#39;axe des X y = &quot;Bill depth (mm)&quot;, # titre de l&#39;axe des Y col = &quot;Species&quot;) + # Légende pour les couleurs dans aes(col = species) theme_classic() + # Utiliser un thème propre theme(title = element_text(size = 18, face = &quot;bold&quot;), text = element_text(size = 16)) En différenciant les espèces, on peut voir qu’il existe une relation assez cohérente entre la longueur et la profondeur du bec entre les espèces (pentes similaires), mais que les gammes de ces variables sont différentes (les regroupements sont clairement indiqués par les couleurs). Les pingouins Adélie ont tendance à avoir une longueur de bec plus petite mais une profondeur de bec assez grande, alors que l’inverse est vrai pour les pingouins Gentoo. 6.4 La dynamique ggplot() par couches Comme nous l’avons vu, un graphique est constitué de différentes couches, combinées ensemble pour communiquer visuellement des informations dans nos données. Construisons un graphique ggplot étape par étape en ajoutant une couche à la fois. Le code ggplot2 est plus facile à lire si chaque ligne représente un nouvel élément. C’est ce style qui est généralement privilégié pour le code ggplot2 dans la communauté R. Cela signifie que lorsque vous ajoutez chaque couche, vous devriez commencer une nouvelle ligne. Figure 6.4: Image adapted from The Grammar of Graphics. 6.4.1 La couche de données # Couche 1: Données ggplot(data = penguins) # Sans autre information, vos données ne seront pas # visualisées. 6.4.2 La couche d’esthétiques Dans ggplot2, l’esthétique est un groupe de paramètres qui spécifie les données à afficher et la manière de les afficher. Ici, nous demandons à R de tracer longueur_de_bill_mm sur l’axe x et profondeur_de_bill_mm sur l’axe y. Nous n’avons pas encore dit à R comment nous voulons représenter les données, donc nos données ne seront pas encore tracées. # Prochaine couche: esthétiques Ici, nous disons à R de # tracer la longueur sur l&#39;axe des x, et la profondeur sur # l&#39;axe des y. mais nous n&#39;avons toujours pas dit à R # comment nous voulons que ces données soient # représentées... ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm)) # Vous voyez ? Nos variables sont maintenant assignées aux # axes x et y, mais rien n&#39;est encore tracé. 6.4.3 La couche de géométries Les objets géométriques, ou geoms, déterminent la représentation visuelle de vos données. Nous pouvons commencer par représenter nos points de données sous la forme d’un nuage de points, pour voir comment la profondeur et la longueur du bec sont liées l’une à l’autre. # Prochaine couche(s): géométries ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + # Utilisez le signe + pour ajouter chaque couche geom_point() # La couche geom détermine le type de tracé que nous utilisons. # geom_point() trace les données sous forme de points ! Notez que vous pouvez ajouter plusieurs geoms dans un seul graphique. Par exemple, nous pouvons ajouter une ligne sur ce graphique pour montrer une valeur seuil, ou ajouter une régression linéaire. Pour l’instant, gardons la simplicité! 6.4.4 Facettes, coordonnées, et thèmes Maintenant que le jeu de données est représenté graphiquement, nous pouvons personnaliser le graphique pour clarifier le message ou ajouter des informations supplémentaires. Les facettes sont un moyen populaire de diviser un graphique en plusieurs fenêtres selon une catégorie de données, afin de différencier visuellement les groupes. Nous pouvons explorer ce graphique différemment si nous utilisons facet_wrap() pour créer des ‘facettes’ séparées en fonction de nos groupes d’espèces: # Prochaine couche(s): customizations! Les facettes # divisent un graphique en fenêtres séparées selon une # certaine catégorie dans les données. ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point() + facet_wrap(vars(species)) # Cela divise le graphique en trois fenêtres : une par espèce. Note: Vous pouvez aussi utiliser facet_grid() si vous voulez faire une facette selon deux variables. Nous pouvons également ajuster l’échelle de nos axes dans le graphique lui-même, plutôt que de transformer les données. Supposons que nous souhaitions étudier la relation entre les mesures du bec sur une échelle de \\(log_{10}\\). ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point() + facet_wrap(vars(species)) + # ceci transforme les coordonnées des axes avec log10() geom_point() geom_point() + facet_wrap(vars(species)) + # ceci transforme les coordonnées des axes avec log10() + geom_point() + facet_wrap(vars(species)) + # ceci transforme les coordonnées des axes avec log10() facet_wrap(vars(species)) geom_point() + facet_wrap(vars(species)) + # ceci transforme les coordonnées des axes avec log10() + geom_point() + facet_wrap(vars(species)) + # ceci transforme les coordonnées des axes avec log10() # geom_point() + facet_wrap(vars(species)) + # ceci transforme les coordonnées des axes avec log10() ceci geom_point() + facet_wrap(vars(species)) + # ceci transforme les coordonnées des axes avec log10() transforme geom_point() + facet_wrap(vars(species)) + # ceci transforme les coordonnées des axes avec log10() les geom_point() + facet_wrap(vars(species)) + # ceci transforme les coordonnées des axes avec log10() coordonnées geom_point() + facet_wrap(vars(species)) + # ceci transforme les coordonnées des axes avec log10() des geom_point() + facet_wrap(vars(species)) + # ceci transforme les coordonnées des axes avec log10() axes geom_point() + facet_wrap(vars(species)) + # ceci transforme les coordonnées des axes avec log10() avec geom_point() + facet_wrap(vars(species)) + # ceci transforme les coordonnées des axes avec log10() log10() coord_trans(x = &quot;log10&quot;, y = &quot;log10&quot;) Pour terminer, nous pouvons également personnaliser le thème du graphique, qui comprend son arrière-plan, les quadrillages et d’autres caractéristiques visuelles du graphique. Supposons que nous n’aimons pas le fond gris par défaut de ggplot2 (nous ne serions pas les seuls!). Nous pouvons utiliser theme_bw() pour produire un rendu visuel plus attrayant. Nous discuterons des thèmes dans le chapitre 11! ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point() + facet_wrap(vars(species)) + coord_trans(x = &quot;log10&quot;, y = &quot;log10&quot;) + # ce thème produit un rendu visuel plus attrayant y y = &quot;log10&quot;) + # ce thème produit un rendu visuel plus attrayant = y = &quot;log10&quot;) + # ce thème produit un rendu visuel plus attrayant &quot;log10&quot;) y = &quot;log10&quot;) + # ce thème produit un rendu visuel plus attrayant + y = &quot;log10&quot;) + # ce thème produit un rendu visuel plus attrayant # y = &quot;log10&quot;) + # ce thème produit un rendu visuel plus attrayant ce y = &quot;log10&quot;) + # ce thème produit un rendu visuel plus attrayant thème y = &quot;log10&quot;) + # ce thème produit un rendu visuel plus attrayant produit y = &quot;log10&quot;) + # ce thème produit un rendu visuel plus attrayant un y = &quot;log10&quot;) + # ce thème produit un rendu visuel plus attrayant rendu y = &quot;log10&quot;) + # ce thème produit un rendu visuel plus attrayant visuel y = &quot;log10&quot;) + # ce thème produit un rendu visuel plus attrayant plus y = &quot;log10&quot;) + # ce thème produit un rendu visuel plus attrayant attrayant theme_bw() 6.5 Défi 1 Il est maintenant temps d’essayer de construire votre propre graphique ! Créez un ggplot pour répondre aux questions suivantes: 1. Y a-t-il une relation entre la longueur des becs et la longueur des nageoires des pingouins? 2. La longueur des becs augmente-t-elle avec celle des nageoires? Paramètres à prendre en compte pour répondre à cette question: données géométrie valeurs x valeurs y penguins geom_point bill_length_mm flipper_length_mm 6.5.1 Défi 1: Solution Créons un nuage de points avec la longueur du bec sur l’axe des x et la longueur de la nageoire sur l’axe des y, afin de visualiser la relation entre ces deux variables. # Faire un nuage de points pour visualiser la relation # entre nos variables ggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm)) + geom_point() L’esthétique peut être soit dans la ligne ggplot(), et sera héritée par tous les géomètres, soit dans la ligne geom_() pour ne s’appliquer qu’à ce géomètre. Voici un exemple. # Personnalisez la forme et la couleur des points ggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm)) + geom_point(shape = 2, color = &quot;blue&quot;) Les couleurs, l’alpha (transparence), la forme et la taille peuvent être définies en dehors des valeurs de aes(), et seront statiques, sans dépendre des données. Ici, le bleu ne transmet aucune information dans les données - c’est juste un choix que nous avons fait pour rendre le graphique plus joli. Ce graphique semble montrer une relation positive entre la longueur du bec et la longueur des nageoires pour tous les individus mesurés dans l’ensemble des données. Ainsi, les pingouins avec un bec plus long ont tendance à avoir des nageoires plus longues. Nous pouvons continuer à creuser cette relation en nous basant sur ce graphique! "],["esthétiques.html", "Chapitre 7 Esthétiques", " Chapitre 7 Esthétiques Parlons plus en détail de la couche esthétique. C’est ici que nous pouvons être vraiment créatifs avec nos données! Nous pouvons utiliser l’esthétique (aes()) pour distinguer les classes, les groupes et la structure. Dans cette section, nous parlerons de la couleur, de la forme, de la taille, des étiquettes et de la transparence afin que vous puissiez faire en sorte que vos graphiques ressemblent exactement à ce que vous avez imaginé. Figure 7.1: L’esthétique nous permet de représenter plusieurs dimensions de notre ensemble de données dans un seul graphique en variant la couleur, la forme, la taille, les légendes et la transparence. "],["les-couleurs-faites-parler-vos-données.html", "Chapitre 8 Les couleurs: faites parler vos données 8.1 Utiliser aes() pour changer les couleurs 8.2 Changer les couleurs manuellement 8.3 Gradients 8.4 Utiliser une palette de couleurs prédéfinie 8.5 Utiliser des palettes de couleurs visibles pour les daltoniens", " Chapitre 8 Les couleurs: faites parler vos données Lorsque nous concevons des graphiques, nous pouvons vouloir changer la couleur de nos points de données afin de communiquer différentes informations sur les données. Nous pouvons vouloir: Différencier entre des groupes Représenter les valeurs des données Mettre en évidence des éléments spécifiques Référence: Fundamentals of Data Visualization (???). 8.1 Utiliser aes() pour changer les couleurs Nous pouvons utiliser la couche esthétique aes() pour associer des couleurs à nos données dans nos graphiques. Cela nous permettra de communiquer clairement des messages spécifiques sur nos données. Par exemple, si nous voulons savoir si la longueur du bec et la longueur des nageoires varient différemment d’une espèce à l’autre, lequel de ces graphiques nous permet de répondre à cette question? # No colour mapping ggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm)) + geom_point() + geom_smooth(method = lm) + labs(title = &quot;Sans code de couleur&quot;, x = &quot;Longueur du bec (mm)&quot;, y = &quot;Profondeur du bec (mm)&quot;) # Avec code de couleur ggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm, col = species)) + # l&#39;argument col met une couleur par espèce geom_point() + geom_smooth(method=lm) + labs(title = &quot;Avec code de couleur&quot;, x = &quot;Longueur du bec (mm)&quot;, y = &quot;Profondeur du bec (mm)&quot;) 8.2 Changer les couleurs manuellement Dans l’exemple ci-dessus, nous avons utilisé l’argument col dans aes() afin de colorer automatiquement nos points de données par espèce. Ceci est possible car aes() peut appeler nos variables de données. Cependant, cette méthode utilisera une palette de couleurs par défaut. Si nous voulons ajouter des couleurs spécifiques à nos graphiques, nous pouvons le faire manuellement en utilisant scale_colour_manual() ou scale_fill_manual(). # Défaut # Permettre à ggplot d&#39;assigner un code de couleurs aux # espèces pp &lt;- ggplot(data = penguins) + geom_point(aes(x = bill_length_mm, y = bill_depth_mm, colour = species)) + labs(title = &quot;Default&quot;, x = &quot;Longueur du bec (mm)&quot;, y = &quot;Profondeur du bec (mm)&quot;) pp # Créer un code de couleur manuellement # En utilisant scale_colour_manual(), # nous pouvons spécifier les couleurs précises que nous voulons utiliser pp + scale_colour_manual( # Notez que l&#39;ordre des couleurs correspondra à # l&#39;ordre des espèces indiqué dans la légende values = c(&quot;grey55&quot;, &quot;orange&quot;, &quot;skyblue&quot;)) Ici, nous enregistrons notre graphique en tant qu’objet (pp), et nous ajoutons des éléments à cet objet avec un + pour changer l’échelle de couleurs. Nous n’avons pas besoin de réécrire tout le ggplot pour le personnaliser! 8.3 Gradients Nous pouvons faire la même chose avec des gradients de couleur en utilisant scale_colour_gradient() si nous voulons communiquer quelque chose sur nos données continues. Dans cet exemple, nous colorons nos points de données par masse corporelle en utilisant un gradient. # Défaut # L&#39;utilisation de l&#39;argument couleur dans aes() va # utiliser une palette de couleurs par défaut pour créer # notre gradient. pp2 &lt;- ggplot(data = penguins) + geom_point(aes(x = bill_length_mm, y = bill_depth_mm, colour = log10(body_mass_g))) + labs(title = &quot;Défaut&quot;, x = &quot;Longueur du bec (mm)&quot;, y = &quot;Profondeur du bec (mm)&quot;) pp2 # Manual # En utilisant scale_colour_graduent, nous pouvons définir # manuellement notre gradient de couleur. pp2 + scale_colour_gradient(low = &quot;blue&quot;, high = &quot;red&quot;) + labs(title = &quot;Manuellement&quot;) # Note : il existe aussi scale_colour_gradient2() pour # créer un # gradient avec une valeur médiane pour les # palettes divergentes. 8.4 Utiliser une palette de couleurs prédéfinie Si vous préférez utiliser une palette de couleurs prédéfinie plutôt que de définir vos couleurs manuellement, mais que vous ne souhaitez pas utiliser la palette par défaut, ne vous inquiétez pas! De nombreuses options s’offrent à vous. Il existe de nombreuses librairies de couleurs R spécialement conçus pour vous fournir une gamme d’options de palette de couleurs! Par exemple, la librairie RColorBrewer propose 35 palettes! Vous pouvez voir ici qu’elles sont organisées en palettes séquentielles, divergentes ou un mélange des deux. Vous pouvez imaginer que différentes palettes sont plus pertinentes pour différents types de données. require(RColorBrewer) display.brewer.all() Vous voulez voir ces palettes en action? Voici un exemple d’utilisation de la palette Dark2 pour grouper des points de données avec la fonction scale_colour_brewer() et l’argument palette. # Palette pour des groupes pp + scale_colour_brewer(palette = &quot;Dark2&quot;) + labs(title = &quot;Palette pour des groupes&quot;) There are other functions within the RColorBrewer package as well. By using scale_color_viridis(), we can use a default package that will translate from colour to gray scale without losing information. (Note that this is also an important consideration for colourblindness, which we will discuss soon). # Palette pour des variables continues pp2 + scale_color_viridis_c() + labs(title = &quot;Palette pour des variables continues&quot;) Maintenant, que faire si nous voulons utiliser uniquement la palette de gris à des fins de publication? Nous pouvons utiliser la fonction scale_colour_grey() pour colorer nos points de données. # Palette pour groupes pp + scale_colour_grey() + labs(title = &quot;Palette pour des groups&quot;) Ou nous pouvons utiliser la fonction scale_colour_gradient() pour les données continues, et définir notre gradient du noir au gris clair. # Palette pour des variables continues pp2 + scale_colour_gradient(low = &quot;grey85&quot;, high = &quot;black&quot;) + labs(title = &quot;Palette for continuous values&quot;) 8.5 Utiliser des palettes de couleurs visibles pour les daltoniens Comment votre figure peut-elle apparaître sous différentes formes de daltonisme ? Nous pouvons utiliser la librairie colorBlindness. install.packages(&quot;colorBlindness&quot;) library(colorBlindness) Commençons par tester quelques couleurs en utilisant la fonction cvdPlot(). Cela nous montrera comment notre graphique actuel se présente pour différentes formes de daltonisme. cvdPlot(pp) # Vérifions le résultat de notre graphique selon les différentes formes de daltonisme. Comme vous pouvez le constater, notre palette de couleurs actuelle n’est pas accessible ! En utilisant les palettes viridis, nous pouvons garantir que nos graphiques communiquent toujours les mêmes informations, quel que soit le public. 8.5.1 Example pour des variables qualitatives Voici un exemple avec des variables qualitatives (en groupes) # Utilisons une palette viridis pour rendre notre graphique # plus accessible. pp_viridis &lt;- pp + scale_colour_viridis_d() + labs(title = &quot;Palette viridis palette pour des groupes&quot;) pp_viridis # Avons-nous réussi ? Utilisons cvdPlot() pour vérifier à # nouveau. cvdPlot(pp_viridis) # On a réussi! 8.5.2 Exemple pour variables continues Notez que nous utilisons des fonctions légèrement différentes pour les différentes types de données (ex. scale_colour_viridis_c(), scale_colour_viridis_d()). pp2_viridis &lt;- pp2 + scale_colour_viridis_c() + labs(title = &quot;Palette viridis pour des variables continues&quot;) pp2_viridis cvdPlot(pp2_viridis) "],["changer-la-forme-la-taille-et-la-transparence.html", "Chapitre 9 Changer la forme, la taille et la transparence 9.1 Défi 2", " Chapitre 9 Changer la forme, la taille et la transparence Maintenant, regardons plus loin que la couleur ! Si nous voulons changer la forme de nos points de données, nous pouvons commencer par utiliser l’argument shape dans la couche aes() comme nous l’avons fait avec la couleur. Cela regroupera nos points de données par la variable que nous fournissons en utilisant différentes formes (ici nous utilisons la variable espèce). Si nous voulons ajuster la taille des points de données, nous pouvons utiliser l’argument size au même endroit. Nous pouvons également utiliser l’argument alpha si nous voulons jouer avec la transparence. Les deux sont de bonnes options pour les données continues. # changer la forme des points ggplot(data = penguins) + geom_point(aes(x = bill_length_mm, y = bill_depth_mm, shape = species)) + # regrouper les données par formes labs(title = &quot;Formes pour des groupes&quot;) # size and alpha for continuous values ggplot(data = penguins) + geom_point(aes(x = bill_length_mm, y = bill_depth_mm, size = body_mass_g, # regrouper les données par taille des points alpha = flipper_length_mm)) + # code de transparence par longueur de nageoire labs(title = &quot;Taille et transparence pour des variables continues&quot;) Notez que le fait de définir simultanément de nombreuses variables pour les repères visuels tels que la couleur, la forme, la taille et l’alpha a tendance à être excessif pour le lecteur. L’ajout de quatre niveaux de complexité à la représentation en 2D des points peut être trop important pour être bien interprété. Il est préférable de choisir les indices visuels et les variables clés pour le message souhaité plutôt que de surcharger un graphique avec toutes les possibilités de la fonction aes(). 9.1 Défi 2 Créer un graphique informatif à partir de jeu de données disponible de R, comme mtcars, CO2 ou msleep. Utiliser les esthétiques appropriés pour différents types de données Données x y Esthétiques mtcars wt mpg disp et hp CO2 conc uptake Treatment et Type msleep log10(bodywt) awake vore et conservation ToothGrowth dose len supp Faites attention aux types de données ! 9.1.1 Défi 2: Solution (mtcars) There are multiple ways to respond to this challenge. Here is one example using the mtcars dataset: Données x y Esthétiques mtcars wt mpg disp et hp # Une de plusieurs solutions: mtcars data(mtcars) ggplot(data = mtcars) + geom_point(aes(x = wt, y = mpg, colour = disp, alpha = hp)) Pourriez-vous utiliser size au lieu de alpha? Et shape? 9.1.2 Défi 2: Solution (CO2) Voici un autre exemple avec le jeu de donnéesCO2: Données x y Esthétiques CO2 conc uptake Treatment et Type # Another possible solution data(CO2) ggplot(data = CO2) + geom_point(aes(x = conc, y = uptake, colour = Treatment, shape = Type)) 9.1.3 Défi 2: Solution (msleep) Voici un autre exemple avec le jeu de données msleep: Données x y Esthétiques msleep log10(bodywt) awake vore et conservation # Une autre solution data(msleep) ggplot(data = msleep) + geom_point(aes(x = log10(bodywt), y = awake, colour = vore, shape = conservation)) 9.1.4 Défi 2: Solution (ToothGrowth) Voici un dernier exemple avec le jeu de données ToothGrowth: Données x y Esthétiques ToothGrowth dose len supp data(ToothGrowth) ggplot(ToothGrowth, aes(x = dose, y = len, color = supp)) + geom_point() + geom_smooth(method = lm, formula = &quot;y ~ x&quot;) "],["changer-léchelle-des-axes.html", "Chapitre 10 Changer l’échelle des axes", " Chapitre 10 Changer l’échelle des axes Nous pouvons également ajuster l’échelle de nos axes en utilisant la fonction coord_trans(). Parfois, la transformation de nos axes est nécessaire pour montrer certaines relations dans nos données. Un exemple courant est une transformation logarithmique avec log10(). Comparons un exemple avec des axes non transformés, puis des axes transformés en \\(log_{10}\\). Exemple A : axe des x à l’échelle originale (non transformée) ggplot(diamonds) + geom_point(aes(x = carat, y = price)) + labs(title = &quot;Original scale&quot;) Exemple B : axe des x et axe des y à l’échelle \\(log_{10}\\). ggplot(diamonds) + geom_point(mapping = aes(x = carat, y = price)) + coord_trans(x = &quot;log10&quot;, y = &quot;log10&quot;) + labs(title = &quot;log10 scale&quot;) Il est également possible de transformer le système de coordonnées en utilisant scale_x_log10() et scale_y_log10(). "],["theme.html", "Chapitre 11 Utiliser le theme() pour faire bonne figure! 11.1 Introduction aux thèmes 11.2 Les élements d’un thème 11.3 Créer votre propre thème 11.4 Plus de thèmes", " Chapitre 11 Utiliser le theme() pour faire bonne figure! 11.1 Introduction aux thèmes Dans ce livre, nous avons utilisé theme_classic() pour les figures, puisque le fond gris défini par défaut peut rendre certaines couleurs plus difficiles à voir. Mais, comme toute autre partie de la grammaire graphique, nous pouvons modifier le thème du graphique pour l’adapter à nos besoins, ou à notre goût ! Il y a beaucoup trop d’éléments de thème intégrés à la librairie ggplot2 pour les mentionner ici, mais vous pouvez trouver une liste complète dans la vignette theme. Au lieu de modifier les nombreux éléments contenus dans theme(), vous pouvez partir des fonctions de thème, qui contiennent un ensemble spécifique d’éléments à partir desquels vous pouvez commencer. Voici quelques exemples : 11.1.1 Thème par défaut: Gris # Theme grey pp + scale_colour_grey() + # Dessiner les points en gris theme_grey() + # Utiliser le fond gris labs(title = &quot;Défaut: Thème gris&quot;) # Titre de la figure 11.1.2 Thème classique pp + scale_colour_grey() + # Dessiner les points en gris theme_classic() + # Utiliser un fond blac labs(title = &quot;Thème classique&quot;) # Titre de la figure 11.1.3 Thème minimal pp + scale_colour_grey() + theme_minimal() + # Utiliser un fond blanc et un quadrillage labs(title = &quot;Thème minimal&quot;) 11.1.4 Définir le thème pour plusieurs graphiques Comme vous avez pu le remarquer, le code de ggplot peut rapidement devenir long lorsque vous devez constamment spécifier les caractéristiques du théme. Lorsque vous créez plusieurs graphes et que vous voulez qu’ils aient tous le même thème, vous pouvez simplement utiliser theme_set() pour définir un thème pour tous les figures qui sont générés par la suite, ou theme_update() pour modifier les éléments d’un thème existant sans réécrire tous les autres éléments du thème. 11.1.4.1 Définir le thème # Définir le thème noir et blanc pour tous les figures qui # suivent theme_set(theme_bw()) # Note: le fond est blanc avec un cadre noir pp Après avoir utilisé theme_set(), notre graphique pp est généré avec le thème noir et blanc theme_bw(). Tous les futurs figures produites dans votre session R seront également générées avec ce thème. 11.1.4.2 Mettre le thème à jour Peut-être que les le quadrillage mineur n’est pas nécessaire pour cette figure, bien que nous aimons tout le reste de notre thème. Plutôt que de réécrire plusieurs lignes de code pour redéfinir le thème, nous pouvons simplement utiliser theme_update() pour ajuster un élément spécifique de notre thème. theme_update(panel.grid.minor = element_blank()) # Enlever le quadrillage &#39;minor&#39; pp Voilà! C’est beaucoup mieux! 11.2 Les élements d’un thème Voici une infographie utile pour vous aider à personnaliser votre thème! Figure 11.1: Fiche de référence du thème ggplot2 (EN) par Isabella Benabaye (source). 11.3 Créer votre propre thème Une fois que vous aurez appris à personnaliser les thèmes ggplot existants, vous pourrez créer votre propre thème pour vos graphiques. C’est un excellent moyen de faire ressortir vos figures dans une présentation, une publication, un site Web ou tout autre endroit! Voici un exemple: mytheme &lt;- theme_bw() + # Vous pouvez partir d&#39;un thème existant pour mettre en place certains éléments de base. theme(plot.title = element_text(colour = &quot;red&quot;)) + theme(legend.position = c(0.9, 0.9)) pp + mytheme # A# Appliquez-le à votre figure! 11.4 Plus de thèmes La librairie ggthemes est un grand projet développé par Jeffrey Arnold sur GitHub et également hébergé sur le dépôt CRAN. Le paquet contient de nombreux thèmes, géomètres et rampes de couleurs pour ggplot2 qui sont basés sur les travaux de certains des noms les plus renommés et les plus influents dans le monde de la visualisation de données, des classiques comme Edward Tufte aux journalistes et programmeurs de données modernes du blog FiveThirtyEight. La librairie peut être installée comme suit: install.packages(&quot;ggthemes&quot;) library(ggthemes) Nous pouvons ensuite appliquer certains de ces thèmes (et plus encore) à notre figure! # Utilisons le thème du blog FiveThirtyEight et la palette # de couleurs de Tableau. pp + theme_fivethirtyeight() + scale_color_tableau() # Utilisons le thème de Tufte &#39;Données maximales, encre # minimale&#39;. pp + theme_tufte() "],["utiliser-des-facettes-pour-diviser-votre-figure.html", "Chapitre 12 Utiliser des facettes pour diviser votre figure 12.1 Facettes selon une variable 12.2 Facettes selon deux variables 12.3 Titre et axes: changer la taille, la couleur et l’apparence 12.4 Défi 3", " Chapitre 12 Utiliser des facettes pour diviser votre figure 12.1 Facettes selon une variable ggplot(data = penguins) + geom_point(mapping = aes(x = bill_length_mm, y = bill_depth_mm, colour = species)) + facet_grid(~species, scales = &quot;free&quot;) # l&#39;échelle de l&#39;axe des y peut varier entre les facettes. # ne faites pas ceci si vous comparez des facettes via # l&#39;axe des y ! 12.2 Facettes selon deux variables ggplot(data = penguins) + geom_point(mapping = aes(x = bill_length_mm, y = bill_depth_mm, colour = species)) + facet_grid(year ~ species, scales = &quot;free&quot;) 12.3 Titre et axes: changer la taille, la couleur et l’apparence Revenons à notre visualisation des données de pingouins. # Revenons à notre visualisation des données de pingouins. pp Nous pouvons ajuster les axes et les titres pour rendre les informations plus claires, afin que le graphique parle par lui-même. 12.4 Défi 3 Utilisez les données tips qui se trouvent dans reshape2 📦 pour reproduire le graphique ci-dessous. # install and load the package install.packages(&quot;reshape2&quot;) ## Installing package into &#39;/home/runner/work/_temp/Library&#39; ## (as &#39;lib&#39; is unspecified) library(reshape2) Notre conseil: Allez-y étape par étape! Commencez par theme_classic() et ajoutez theme() pour faire vos changements supplémentaires. 12.4.1 Défi 3: Solution # Construire le graphique tips.gg &lt;- ggplot(tips, # Étape 1. Spécifiez le mappage esthétique des axes et des légendes aes(x = facture_totale, y = pourboire/facture totale, shape = fumeur, couleur = sexe, size = taille)) + # Étape 2. Spécifiez le geom utilisé pour représenter les données geom_point() + # Etape 3. Spécifiez la variable utilisée pour faire des facettes facet_grid( ~ time) + # Étape 4. Spécifiez l&#39;échelle de couleur utilisée pour représenter le sexe scale_colour_grey() + # Étape 5. Étiquettez le titre et les axes du graphique labs(title = &quot;Relation entre l&#39;addition totale et les pourboires pendant le déjeuner et le dîner&quot;, x = &quot;Facture totale ($)&quot;, y = &quot;Rapport entre les pourboires et l&#39;addition totale&quot;) + # Étape 6. Définissez le thème theme_classic() + # Étape 7. Personnalisez le thème pour qu&#39;il corresponde à la taille et à la couleur des titres du graphique. theme(axis.title = element_text(size = 16, couleur = &quot;navy&quot;), axis.text = element_text(size = 12), plot.title = element_text(size = 16, couleur = &quot;orange3&quot;, face = &quot;bold&quot;), # cette partie ajuste le texte dans les titres des facettes strip.text.x = element_text(size = 14, face=&quot;bold&quot;)) # générez notre beau graphique ! tips.gg "],["utiliser-geom_-pour-créer-différents-types-de-graphique.html", "Chapitre 13 Utiliser geom_*() pour créer différents types de graphique 13.1 Histogrammes: geom_histogram() 13.2 Nuage de points et régression linéaire: geom_point() et geom_smooth() 13.3 Diagramme en boîte: geom_boxplot(): 13.4 Diagramme en boîte avec annotations: geom_boxplot() and geom_signif() 13.5 Diagramme en violon: geom_violin() 13.6 Résumer des valeurs y: stat_summary() 13.7 Créer des cartes: geom_map() 13.8 Graphique de densité: geom_density() 13.9 Dendogramme: ggdendrogram()", " Chapitre 13 Utiliser geom_*() pour créer différents types de graphique Plusieurs geoms peuvent être utilisés ensemble dans un seul graphique ! L’ordre détermine comment ils se superposent. Voici un graphique vide, avant que nous n’ajoutions des geom_* pour représenter les variables de notre jeu de données. ggplot(penguins) 13.1 Histogrammes: geom_histogram() Un histogramme est une représentation graphique précise de la distribution de données numériques. Il n’y a qu’une seule esthétique requise: la variable x. ggplot(penguins, aes(x = bill_length_mm)) + geom_histogram() + ggtitle(&quot;Histogramme de la longeur des becs&quot;) 13.2 Nuage de points et régression linéaire: geom_point() et geom_smooth() Un nuage de points est un excellent moyen de visualiser des points de données pour deux variables. Deux esthétiques sont requises dans geom_point(): les variables x et y. ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + labs(title = &quot;Nuage de points&quot;) Il peut cependant être difficile de discerner toute relation potentielle dans un nuage de points. Vous pouvez utiliser geom_smooth() pour ajuster une ligne à travers vos données avec une variété de méthodes. Ici, nous allons ajouter une régression linéaire au nuage de points. ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + geom_smooth(method = lm) + labs(title = &quot;Régression linéaire&quot;) 13.3 Diagramme en boîte: geom_boxplot(): Les diagrammes en boîte (ou boxplot) sont un moyen populaire de représenter la distribution des données en fonction d’une variable qualitative, comme les espèces. Vous pouvez spécifier cette variable dans aes() en utilisant group =, ou l’esthétique utilisée pour représenter les données (fill =, col =, shape =) dans le boxplot. ggplot(data = penguins, aes(x = species, y = bill_length_mm, fill = species)) + # définir espèce comme variable de groupe (par couleur) geom_boxplot() + labs(title = &quot;Boxplot&quot;) Bien que les diagrammes en boîte soient très populaires pour résumer les données, quelqu’un qui regarde votre graphique peut ne pas comprendre intuitivement comment fonctionne ce résumé et ce qu’il peut masquer. Pour bien utiliser les diagrammes en boîte, il faut en comprendre la composition, comme illustré ci-dessous. Plus d’informations sur les inconvénients des diagrammes en boîte se trouvent ici. Figure 13.1: Composition d’un diagramme en boîte by Denise Coleman. 13.4 Diagramme en boîte avec annotations: geom_boxplot() and geom_signif() Pour guider l’interprétation des diagrammes en boîte, nous pouvons ajouter des annotations avec geom_signif(). La fonction geom_signif() calcule la significativité d’une différence entre les groupes et ajoute l’annotation au graphique en une seule ligne de code. library(ggsignif) ggplot(data = penguins, aes(x = species, y= bill_length_mm, fill = species)) + geom_boxplot() + geom_signif( # which groups should be compared? comparisons = list(c(&quot;Adelie&quot;, &quot;Gentoo&quot;)), map_signif_level=TRUE) 13.5 Diagramme en violon: geom_violin() Comme les diagrammes en boîte, les diagrammes en violon visualisent la distribution d’une variable numérique pour un ou plusieurs groupes. Cependant, la forme d’un violon représente la distribution des points qui est masquée dans le résumé d’un boxplot, ce qui permet une représentation plus précise des données (Data-to-Viz)). Comparons un diagramme en boîte et un diagramme en violon sur des données générées. Remarquez comment le diagramme en violon montre l’étendue et la variabilité de nos données, alors que le diagramme en boîte ne peut pas communiquer ces deux éléments de manière aussi intuitive. On peut faire un diagramme en violin avec nos données penguins: violin &lt;- ggplot(data = penguins, aes(x = species, y = bill_length_mm)) + geom_violin(trim = FALSE, # ne pas tailler les extrémités des violons s&#39;il y a des valeurs extrêmes fill = &quot;grey70&quot;, # mettre tous les violons en gris alpha = .5) + # transparence de la couleur de remplissage labs(title = &quot;Violin plot&quot;) violin Bien que nous ayons une bonne idée de la façon dont les données sont distribuées, nous pouvons améliorer le graphique en visualisant certaines statistiques sommaires et les points de données. Traçons un boxplot et les points de données sur notre graphique de violon avec geom_violin() + geom_boxplot() + geom_jitter(). violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent violin violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent + violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent # violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent ce violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent geom violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent trace violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent les violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent points violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent de violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent données violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent avec violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent un violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent peu violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent de violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent bruit violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent supplémentaire violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent (horizontal) violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent pour violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent voir violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent les violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent points violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent qui violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent se violin + # ce geom trace les points de données avec un peu de bruit supplémentaire (horizontal) pour voir les points qui se chevauchent chevauchent geom_jitter(shape = 16, position = position_jitter(0.2), alpha = 0.3) + geom_boxplot(width = 0.05) 13.6 Résumer des valeurs y: stat_summary() L’ajout de statistiques sommaires à votre tracé peut aider à mettre en évidence le message clé de votre graphique. La fonction stat_summary() peut exécuter la statistique de votre choix en utilisant l’argument fun =, et l’ajouter à votre graphique selon le geom = que vous avez défini dans la fonction. Par exemple, si nous voulions tracer la médiane du nombre de cylindres (cyl) dans l’ensemble de données mtcars, nous utiliserions stat_summary() de la manière suivante : # tracer la médiane du nombre de cylindre ggplot(mtcars, aes(x = cyl, y = mpg)) + geom_point() + stat_summary(fun = &quot;median&quot;, geom = &quot;point&quot;, colour = &quot;red&quot;, size = 6) + labs(title = &quot;Médiannes&quot;) Though the median is a helpful summary statistics, it does not inform us about the uncertainty behind it. If we wanted to instead plot the mean of each group with bootstrapped confidence intervals, we could just switch the fun.data = argument: # Tracez la moyenne de chaque groupe avec des intervalles # de confiance (par bootstrapping) ggplot(mtcars, aes(cyl, mpg)) + geom_point() + stat_summary(fun.data = &quot;mean_cl_boot&quot;, colour = &quot;red&quot;, size = 1.6) + labs(title = &quot;Moyennes et intervalles de confiance&quot;) ## Warning: Computation failed in `stat_summary()`: ## The `Hmisc` package is required. Voir aussi geom_errorbar(), geom_pointrange(), geom_linerange(), geom_crossbar() afficher d’autres statistiques pour résumer vos données. 13.7 Créer des cartes: geom_map() Nous allons cartographier les arrestations pour meurtres pour 100 000 habitants dans chacun des 50 états américains en 1973 à partir de la base de données USArrests avec geom_map(). # charger la librairie maps library(maps) states_map &lt;- map_data(&quot;state&quot;) # obtient une carte des Etats-Unis à l&#39;échelle des états # Le nom de l&#39;état est défini comme rownames. Créons une nouvelle colonne pour ceux-ci # qui correspond à la colonne des noms d&#39;états dans notre states_map. USArrests$region &lt;- tolower(rownames(USArrests)) # Construisons notre carte ggplot(USArrests, aes(map_id = region)) + # le nom de la variable pour lier notre carte et notre dataframe geom_map(aes(fill = Murder), # variable que nous voulons représenter avec une esthétique map = states_map) + # cadre de données qui contient des coordonnées expand_limits(x = states_map$long, y = states_map$lat) + coord_map() + # projection labs(x = &quot;&quot;, y = &quot;&quot;) # suppression des titres des axes 13.8 Graphique de densité: geom_density() Un graphique de densité montre la distribution d’une variable numérique et ne prend en entrée qu’un ensemble de valeurs numériques. (peng.dens &lt;- ggplot(penguins, aes(x = bill_length_mm)) + geom_density()) (cars.dens &lt;- ggplot(cars, aes(x = dist)) + geom_density()) 13.9 Dendogramme: ggdendrogram() Quels états américains ont des taux d’arrestation similaires ? library(ggdendro) USArrests.short &lt;- USArrests[1:10, ] # prendre un petit échantillon pour simplifier hc &lt;- hclust(dist(USArrests.short), &quot;average&quot;) # regroupement par distance moyenne (UPGMA) ## Warning in dist(USArrests.short): NAs introduced by coercion # visualiser le dendrogramme ggdendrogram(hc, rotate = TRUE) "],["disposition-des-graphiques-patchwork.html", "Chapitre 14 Disposition des graphiques: patchwork", " Chapitre 14 Disposition des graphiques: patchwork Jusqu’à présent, nous avons utilisé des facettes pour diviser notre graphique en plusieurs fenêtres. Cependant, ceci est limité au traçage des mêmes variables à partir du même ensemble de données. Le paquet patchwork permet d’arranger facilement des ggplots distincts dans un même cadre avec + (arranger les graphes les uns à côté des autres), / (arranger un graphe par-dessus l’autre), () (grouper cet arrangement de graphes) comme si vous écriviez une équation. # charger patchwork pour arranger nos graphiques de densité library(patchwork) # les ajouter ensemble signifie &#39;les placer les uns à côté # des autres&#39;. peng.dens + cars.dens + plot_annotation(tag_levels = &quot;a&quot;) # ajoute a) et b) à vos figures, afin de # les mentionner ans les descriptions de vos figures. "],["défi-4.html", "Chapitre 15 Défi 4 15.1 Défi 4: Solution exemple 1 15.2 Défi 4: Solution example 2", " Chapitre 15 Défi 4 Créez votre propre graphique et suivez ces recommandations : * Jeu de données : n’importe lequel (recommandation : utilisez votre jeu de données) * Explorez un nouveau geom_* et d’autres couches de graphiques Utilisez les liens suivants pour obtenir des conseils : ggplot2 Reference R Graph Gallery Data to Viz 15.1 Défi 4: Solution exemple 1 data(msleep) ggplot(msleep, aes(x = vore, y = log10(brainwt), fill = vore)) + geom_violin() + geom_signif(comparisons = list(c(&quot;herbi&quot;, &quot;insecti&quot;))) + labs(&quot;Poids du cerveau pour les différents -vores&quot;, y = &quot;log10(Poids du cerveau (Kg))&quot;) + scale_fill_grey() + theme_classic() 15.2 Défi 4: Solution example 2 data(mtcars) # let&#39;s do some clustering! mtcars.short &lt;- mtcars[1:20, ] mtcars.short.hc &lt;- hclust(dist(mtcars.short), &quot;average&quot;) ggdendrogram(mtcars.short.hc, rotate = TRUE) + # fine-tuning ggdendrogram(mtcars.short.hc, ggdendrogram(mtcars.short.hc, rotate = TRUE) + # fine-tuning rotate ggdendrogram(mtcars.short.hc, rotate = TRUE) + # fine-tuning = ggdendrogram(mtcars.short.hc, rotate = TRUE) + # fine-tuning TRUE) ggdendrogram(mtcars.short.hc, rotate = TRUE) + # fine-tuning + ggdendrogram(mtcars.short.hc, rotate = TRUE) + # fine-tuning # ggdendrogram(mtcars.short.hc, rotate = TRUE) + # fine-tuning fine-tuning labs(title = &quot;Dendrogramme des voitures selon les spécifications du moteur&quot;, y = &quot;Voitures&quot;) + theme(axis.title.y = element_text(size = 16), axis.text.y = element_text(size = 12), axis.title.x = element_blank(), axis.text.x = element_blank(), plot.title = element_text(size = 14, face = &quot;bold&quot;)) "],["divers-graphiques-interactifs-avec-plotly.html", "Chapitre 16 Divers : graphiques interactifs avec plotly()", " Chapitre 16 Divers : graphiques interactifs avec plotly() La librairie plotly() contient la fonction ggplotly(), qui traduit votre code ggplot en un objet interactif plotly en une seule ligne de code. Vous pouvez cliquer sur les espèces dans la légende pour ajouter/supprimer des espèces. Vous pouvez également voir les valeurs en passant la souris sur les points. library(plotly) p &lt;- ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, colour = species, shape = species)) + geom_point(size = 6, alpha = 0.6) # convertir en objet plotly! ggplotly(p) "],["section.html", "Chapitre 17 ", " Chapitre 17 "],["sauvegarder-des-graphiques-avec-r.html", "Chapitre 18 Sauvegarder des graphiques avec R", " Chapitre 18 Sauvegarder des graphiques avec R In RStudio, there are many options available to you to save your figures. You could copy them to the clipboard, but it is preferable to export them as a file type of your choice (or export them as any file type (png, jpg, emf, tiff, pdf, metafile, etc). ggsave() is a useful command that saves directly to your working directory and allows you to specify the name of your new file, the dimensions of the plot, the resolution, etc. my1stPlot &lt;- # Créer une figure pour pratiquer comment sauvegarder ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point() ggsave(filename = &quot;my1stPlot.pdf&quot;, # Nommez le fichier dans lequel vous voulez enregistrer, ajoutez l&#39;extension du format de fichier que vous voulez utiliser (ex. pdf). plot = my1stPlot, # Fournir le nom de l&#39;objet plot dans R height = 8.5, # Fournir les dimensions voulues width = 11, units = &quot;in&quot;) # Astuce : Les fonctions `quartz()` (mac) ou `window()` (pc) facilitent le dimensionnement avant `ggsave()` ! Tracez simplement votre ggplot dans quartz() ou window(), ajustez la taille jusqu&#39;à ce qu&#39;elle soit bonne, et lancez ggsave() avec le nom du fichier pour voir quelles dimensions vous avez utilisées ! Vous pouvez ensuite ajouter ceci dans votre code avec height = et width = comme indiqué ci-dessus. Pensez à la marge du document que vous utilisez. Si vous redimensionnez l’image après l’avoir enregistrée, les titres et le texte changeront également de taille, ce qui pourrait être difficile à lire. Notez également que le format vectoriel (par exemple, pdf, svg) est plus flexible que le format raster (jpeg, png, …) si l’image doit être modifiée par la suite. Si vous préférez le format raster, vous pouvez consulter d’autres méthodes pour enregistrer une image en utilisant ?pdf ?jpeg. Dans les cas où vous produisez de nombreux graphiques (par exemple, au cours de longs programmes qui produisent automatiquement de nombreux graphiques tout en effectuant des analyses), il est utile d’enregistrer de nombreux graphiques dans un fichier pdf. Ceci peut être réalisé comme suit: my2ndPlot &lt;- # Créer un 2eme graphique pour pratiquer pdf() ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point() pdf(&quot;./graph_du_jour.pdf&quot;) print(my1stPlot) # print() est nécessaire print(my2ndPlot) graphics.off() "],["considérations-finales.html", "Chapitre 19 Considérations finales", " Chapitre 19 Considérations finales Il y a d’autres librairies utiles qui peuvent être utilisés avec ggplot2 ! Pour en nommer quelques-uns : ggbio, ggpmisc, geomnet, gganimate, ggnetwork et ggtree. Jetez un coup d’oeil à www.ggplot2-exts.org pour d’autres extensions de ggplot2. Notez que vous pouvez en apprendre plus sur la conception et la manipulation d’images avec l’atelier QCBS “Introduction à la conception graphique et à la manipulation d’images avec des outils open source”. "],["ressources-additionelles-en.html", "Chapitre 20 Ressources additionelles (EN) 20.1 Documents de référence 20.2 Livres 20.3 Inspiration et guides 20.4 Notes de cours", " Chapitre 20 Ressources additionelles (EN) 20.1 Documents de référence help(package = ggplot2) Data Visualization with ggplot2 Cheat Sheet ggplot2 Reference 20.2 Livres Fundamentals of Data Visualization 20.3 Inspiration et guides From Data to Viz A Compendium of Clean Graphs in R (base R) Graphics Principles (design tips) The R Graph gallery 20.4 Notes de cours Notes de cours de Stat 405 par Hadley (les autres cours sont intéressants aussi!) http://stat405.had.co.nz/lectures/11-adv-data-manip.pdf http://stat405.had.co.nz/lectures/19-tables.pdf "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
