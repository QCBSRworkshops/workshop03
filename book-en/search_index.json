[["index.html", "Workshop 3: Introduction to ggplot2 QCBS R Workshop Series Preface 0.1 Code of conduct 0.2 Contributors 0.3 Contributing", " Workshop 3: Introduction to ggplot2 QCBS R Workshop Series Developed and maintained by the contributors of the QCBS R Workshop Series1 2021-09-13 19:50:31 Preface The QCBS R Workshop Series is a series of 10 workshops that walks participants through the steps required to use R for a wide array of statistical analyses relevant to research in biology and ecology. These open-access workshops were created by members of the QCBS both for members of the QCBS and the larger community. The content of this workshop has been peer-reviewed by several QCBS members. If you would like to suggest modifications, please contact the current series coordinators, listed on the main Github page. 0.1 Code of conduct The QCBS R Workshop Series and the QCBS R Symposium are venues dedicated to providing a welcoming and supportive environment for all people, regardless of background or identity. Participants, presenters and organizers of the workshop series and other related activities accept this Code of Conduct when being present at any workshop-related activities. We do not tolerate behaviour that is disrespectful or that excludes, intimidates, or causes discomfort to others. We do not tolerate discrimination or harassment based on characteristics that include, but are not limited to, gender identity and expression, sexual orientation, disability, physical appearance, body size, citizenship, nationality, ethnic or social origin, pregnancy, familial status, genetic information, religion or belief (or lack thereof), membership of a national minority, property, age, education, socio-economic status, technical choices, and experience level. It applies to all spaces managed by or affiliated with the workshop, including, but not limited to, workshops, email lists, and online forums such as GitHub, Slack and Twitter. 0.1.1 Expected behaviour All participants are expected to show respect and courtesy to others. All interactions should be professional regardless of platform: either online or in-person. In order to foster a positive and professional learning environment we encourage the following kinds of behaviours in all workshop events and platforms: Use welcoming and inclusive language Be respectful of different viewpoints and experiences Gracefully accept constructive criticism Focus on what is best for the community Show courtesy and respect towards other community members 0.1.2 Unacceptable behaviour Examples of unacceptable behaviour by participants at any workshop event/platform include: written or verbal comments which have the effect of excluding people on the - basis of membership of any specific group; causing someone to fear for their safety, such as through stalking or intimidation; violent threats or language directed against another person; the display of sexual or violent images; unwelcome sexual attention; nonconsensual or unwelcome physical contact; insults or put-downs; sexist, racist, homophobic, transphobic, ableist, or exclusionary jokes; incitement to violence, suicide, or self-harm; continuing to initiate interaction (including photography or recording) with - someone after being asked to stop; publication of private communication without consent. 0.2 Contributors This workshop was originally developed by Xavier Giroux-Bougard, Maxwell Farrell, Amanda Winegardner, √âtienne Low-Decarie and Monica Granados. Since 2014, several QCBS members contributed to consistently and collaboratively develop and update this workshop, as part of the Learning and Development Award from the Qu√©bec Centre for Biodiversity Science. They were: 2022 - 2021 - 2020 2019 - 2018 - 2017 2016 - 2015 - 2014 Linley Sherin Marie-H√©l√®ne Brice Xavier Giroux-Bougard Katherine H√©bert Willian Vieira Maxwell Farrell Jake Lawlor R√©mi Maglione Amanda Winegardner Marie-H√©l√®ne Brice Pedro Henrique P. Braga √âtienne Low-Decarie Kevin Cazelles Alexis Carteron Monica Granados Katherine H√©bert 0.3 Contributing Under construction. The QCBS R Workshop Series is part of the Qu√©bec Centre for Biodiversity Science, and is maintained by the series coordinators and graduent student, postdoctoral, and research professional members. The contributors for this workshop can be accessed here.‚Ü©Ô∏é "],["preparing-for-the-workshop.html", "Chapter 1 Preparing for the workshop", " Chapter 1 Preparing for the workshop All workshop materials are found at github.com/QCBSRworkshops/workshop03. This includes an R script which contains all code chunks shown in this book. You should also make sure you have downloaded, installed, and loaded these packages: gridExtra ggplot2 ggsignif ggdendro maps mapproj RColorBrewer reshape2 GGally patchwork plotly palmerpenguins To install them from CRAN, run: # Install the required packages install.packages(&quot;gridExtra&quot;) install.packages(&quot;ggplot2&quot;) install.packages(&quot;ggsignif&quot;) install.packages(&quot;ggdendro&quot;) install.packages(&quot;maps&quot;) install.packages(&quot;mapproj&quot;) install.packages(&quot;RColorBrewer&quot;) install.packages(&quot;reshape2&quot;) install.packages(&quot;GGally&quot;) install.packages(&quot;patchwork&quot;) # install.packages(&#39;plotly&#39;) install.packages(&quot;palmerpenguins&quot;) To load these packages, run: # Load the required packages library(gridExtra) library(ggplot2) library(ggsignif) library(ggdendro) library(maps) library(mapproj) library(RColorBrewer) library(reshape2) library(GGally) library(patchwork) # library(plotly) library(palmerpenguins) "],["learning-objectives.html", "Chapter 2 Learning objectives 2.1 Workshop outline", " Chapter 2 Learning objectives In this workshop, we will: 1. Learn the basics of data visualization using R. 2. Learn how to find packages and resources to meet your needs. 3. Inspire creativity in science! 4. Develop an understanding of design for effective visual communication. 2.1 Workshop outline Today we will walk you through the basics of ggplot2 so that you have the necessary tools to explore its use for your own projects. We will be covering the following topics: 1. Visualization in science 2. ggplot2 mechanics: the basics 3 Aesthetic mapping 4. Fine-tuning 5. Saving your plots 6. Conclusion "],["why-do-we-visualize-data.html", "Chapter 3 Why do we visualize data?", " Chapter 3 Why do we visualize data? Before we start looking at how we can visualize our data, let‚Äôs first answer why data visualization is important. Visualization can be helpful (or even essential) to represent results of statistical analyses, to formulate hypotheses and summarize theory, to explore your data so that you understand it better via exploratory analysis or outlier detection, and more. Most importantly, visualization is most useful to communicate and report your findings to others when it is done: Clearly (using good design principles); Precisely and accurately (a plot is worth 1000 words); Effectively and efficiently. Here is an example of an ineffective visualization: Figure 3.1: An example of an ineffective visualization. What is wrong with this image? Try to answer for yourself what you think this figure is trying to communicate and whether it is successful. How could this image be improved? Hints: Why is this in 3D? Which elements do your eyes focus on first? How does a pie chart visually communicate the information? To ensure you are communicating effectively, here are some important questions to ask yourself when visualizing your data: What do you want to communicate? Who is your audience? What is the best way to visualize your message? A good rule of thumb: think simple! use less ink! "],["why-use-r.html", "Chapter 4 Why use R? 4.1 Reproducibility 4.2 Powerful features", " Chapter 4 Why use R? Whether you are calculating summary statistics (e.g.¬†Excel), performing more advanced statistical analysis (e.g.¬†JMP, SAS, SPSS), or producing figures and tables (e.g.¬†Sigmaplot, Excel), it is easy to get lost in a workflow when you are using a variety of software. This can become especially problematic when you import and export your dataset to accomplish a downstream task. With each operation, you increase the risk of introducing errors into your data or losing track of the correct version of your data. R provides a solution to this by unifying all of the tools you need for advanced data manipulation, statistical analysis, and powerful graphical engines in a single programming language. By unifying your workflow with R, you can reduce the chance of making mistakes and ensure your work is reproducible. Believe us, the future ‚Äúyou‚Äù will not regret it! Instead of using a suite of software tools‚Ä¶ You can use R to generate reproducible data visualizations all within a single program, R Studio. What is the advantage to using R for data visualization? 4.1 Reproducibility One of the main reasons to use R for plotting is that it makes your visualization entirely reproducible. You can annotate your script, add additional information (ex. titles, labels, captions, etc), and maintain the code for all versions of your figures so you always know how it was produced. Reproducible science comes with effort, but it is quickly becoming an industry standard and is an investment that will save you and your collaborators a lot of time in the long run! 4.2 Powerful features Another reason to use R is its powerful features, like ggplot2. The ggplot2 package is the most flexible and complete package available for advanced data visualization in R. This package was created for R by Hadley Wickham based on the Grammar of Graphics by Leland Wilkinson. Figure 4.1: The source code for the ggplot2 package is hosted on GitHub: github.com/hadley/ggplot2. In this workshop, we focus only on ggplot2, but there are many other packages and functions that can be used for great visualization (e.g., base R, plotly, sjPlot, mapview, igraph). Here are some examples of the plots you can make with base R, or with ggplot2. Figure 4.2: A small sample of plots you can make with base R (row 1) and ggplot2 (row 2), based on the palmerpenguins data package. The reason that we focus on ggplot2 is due to its versatility. 1. The ggplot2 package lets you make beautiful and customizable plots; 2. It implements the grammar of graphics, which is a reliable system for building plots. 3. There are many extensions available to add even more features to ggplot2, allowing for a wealth of applications. "],["grammar-of-graphics-gg-basics.html", "Chapter 5 Grammar of Graphics (GG) basics 5.1 What is the Grammar of Graphics? 5.2 Grammar of Graphics layers", " Chapter 5 Grammar of Graphics (GG) basics 5.1 What is the Grammar of Graphics? Let‚Äôs start with the basics! The package ggplot2 is based on the Grammar of Graphics (GG), which is a framework for data visualization that dissects each component of a graph into individual components, creating distinct layers. Using the GG system, we can build graphs step-by-step for flexible, customizable results. GG layers have specific names that you will see throughout the workshop: Figure 5.1: Image adapted from The Grammar of Graphics. To make a ggplot, the data and mapping layers are basic requirements, while the other layers are for additional customization. The layers that are ‚Äúnot required‚Äù are still important to think about, but you will be able to generate a basic plot without them. Figure 5.2: Basic requirements to generate a ggplot. 5.2 Grammar of Graphics layers 5.2.1 A breakdown of common layers Here is a breakdown of each Grammar of Graphics layer and common arguments for each that can be used as a reference: Data: your data, in tidy format, will provide ingredients for your plot use dplyr techniques to prepare data for optimal plotting format usually, this means you should have one row for every observation that you want to plot Aesthetics (aes), to make data visible x, y: variable along the x and y axis colour: color of geoms according to data fill: the inside color of the geom group: what group a geom belongs to shape: the figure used to plot a point linetype: the type of line used (solid, dashed, etc) size: size scaling for an extra dimension alpha: the transparency of the geom Geometric objects (geoms - determines the type of plot) geom_point(): scatterplot geom_line(): lines connecting points by increasing value of x geom_path(): lines connecting points in sequence of appearance geom_boxplot(): box and whiskers plot for categorical variables geom_bar(): bar charts for categorical x axis geom_histogram(): histogram for continuous x axis geom_violin(): distribution kernel of data dispersion geom_smooth(): function line based on data Facets facet_wrap() or facet_grid() for small multiples Statistics similar to geoms, but computed show means, counts, and other statistical summaries of data Coordinates - fitting data onto a page coord_cartesian to set limits coord_polar for circular plots coord_map for different map projections Themes overall visual defaults fonts, colors, shapes, outlines 5.2.2 Putting these layers together Let‚Äôs try it out! Here are the basic steps to build a plot. You can refer back to these steps throughout the workshop if you need help! Create a simple plot object: plot.object &lt;- ggplot() Add geometric layers: plot.object &lt;- plot.object + geom_*() Add appearance layers: plot.object &lt;- plot.object + coord_*() + theme() Repeat step 2-3 until satisfied, then print: plot.object or print(plot.object) We will come back to this syntax in Chapter 6.4, where we work through the layers in greater depth! "],["the-basics-of-visualizing-data.html", "Chapter 6 The basics of visualizing data 6.1 Today‚Äôs dataset: palmerpenguins 6.2 Asking questions 6.3 Exploring data structure 6.4 Working through the layers 6.5 Challenge 1", " Chapter 6 The basics of visualizing data 6.1 Today‚Äôs dataset: palmerpenguins Now let‚Äôs actually try plotting some data! This workshop will be using the dataset from the palmerpenguins (Horst, Hill, and Gorman 2020) package. Figure 6.1: Artwork by Allison Horst. This dataset contains size measurements for three penguin species observed on three islands in the Palmer Archipelago, Antarctica. These data were collected from 2007 - 2009 by Dr.¬†Kristen Gorman with the Palmer Station Long Term Ecological Research Program, part of the US Long Term Ecological Research Network. Figure 6.2: Artwork by Allison Horst. This dataset is often used to replace the iris dataset, which has some problems for teaching data science, including its ties to eugenics (more on this at armchairecology.blog/iris-dataset). This dataset was also used for a TidyTuesday challenge, showing the many possibilities of visualizing the dataset creatively. For example: this, and this. Let‚Äôs take a look at the variables in the penguins dataset: str(penguins) # let&#39;s have a look at some penguin data! ## tibble [344 √ó 8] (S3: tbl_df/tbl/data.frame) ## $ species : Factor w/ 3 levels &quot;Adelie&quot;,&quot;Chinstrap&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## $ island : Factor w/ 3 levels &quot;Biscoe&quot;,&quot;Dream&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... ## $ bill_length_mm : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ... ## $ bill_depth_mm : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ... ## $ flipper_length_mm: int [1:344] 181 186 195 NA 193 190 181 195 193 190 ... ## $ body_mass_g : int [1:344] 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ... ## $ sex : Factor w/ 2 levels &quot;female&quot;,&quot;male&quot;: 2 1 1 NA 1 2 1 2 NA NA ... ## $ year : int [1:344] 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ... Figure 6.3: Artwork by Allison Horst. Note that species, island, and sex are factor variables, which will be important for grouping the data with colour, shapes, and other aesthetics in ggplot2. There are then two numeric variables (bill measurements depicted in the image), and two integer variables (flipper length and body mass). The data also has a small temporal component (year), spanning the years from 2007 to 2009. ggplot2 requires you to prepare the data as an object of class data.frame or tibble (common in the tidyverse). class(penguins) # check the class of the data to ensure it is either a data.frame or tibble for ggplot2 ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; # you can transform a dataset into a tibble using the # as_tibble() function if need be peng &lt;- # tibble::as_tibble(penguins) class(peng) ‚ôª Recall from the Loading and manipulating data workshop: More complex plots in ggplot2 require the long data frame format. 6.2 Asking questions What are some of the scientific questions we may want to answer with this data-set? Here are some examples: Is there a relationship between the length &amp; the depth of bills? Does the size of the bill &amp; flipper vary together ? How are these measures distributed among the 3 penguin species ? How can we graphically address these questions with ggplot2? 6.3 Exploring data structure If we want a general overview of our data, we can start by using the ggpairs() function from the GGally package (which we loaded and installed in the beginning of the workshop). This will allow us to look at initial relationships and then explore them in more detail. ## Get a general overview of the data with multiple plot ## types ggpairs(penguins, aes(colour = species), progress = FALSE) + theme_bw() We can already see some species groupings between bill length and bill depth, flipper length, and body mass. When plotting, it will be important to keep in mind that differentiating species might be important. Do you see those groupings? We should explore how some of this data is structured by species! # Let&#39;s explore how some of this data is structured by species ggplot(data = penguins, # Data aes(x = bill_length_mm, # Your X-value y = bill_depth_mm, # Your Y-value col = species)) + # Aesthetics geom_point(size = 5, alpha = 0.8) + # Point geom_smooth(method = &quot;lm&quot;) + # Linear regression labs(title = &quot;Relationship between bill length and depth\\nfor different penguin species&quot;, # Title x = &quot;Bill length (mm)&quot;, # X-axis title y = &quot;Bill depth (mm)&quot;, # Y-axis title col = &quot;Species&quot;) + # Colour data point by species (also creates legend) theme_classic() + # Apply a clean theme theme(title = element_text(size = 18, face = &quot;bold&quot;), text = element_text(size = 16)) By differentiating species, we can see that there is a pretty consistent relationship between bill length and depth across species (similar slopes), but that the ranges of these variables is different (the groupings are clearly shown by the colours). Adelie penguins tend to have smaller bill length but fairly large bill depth, while the inverse is true for Gentoo penguins. 6.4 Working through the layers As we have discussed, a graphic is made of different layers, combined together to visually communicate information in our data. Let us build a ggplot graphic step by step by adding one layer at a time. ggplot2 code is easier to read if each line represents a new element. This style is generally favoured for ggplot2 code in the R community. This means that as you add each layer, you should start a new line. Figure 6.4: Image adapted from The Grammar of Graphics. 6.4.1 Data layer # Layer 1: Data ggplot(data = penguins) # Without any other information, your data will not be # visualised. 6.4.2 Aesthetics layer In ggplot2, aesthetics are a group of parameters that specify what and how data is displayed. Here, we are telling R to plot bill_length_mm on the x axis and bill_depth_mm on the y axis. We have not yet told R how we want to represent the data though, so our data will not yet be plotted. # Next layer: aesthetics. Here, we tell R to plot length # on the x axis, and depth on the y axis but we still # haven&#39;t told R how we want these data to be # represented... ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm)) # See? Our variables are now assigned to the x and y axes, # but nothing is plotted yet. 6.4.3 Geometric layer Geometric objects, or geoms, determine the visual representation of your data. We can begin by plotting our data points as a scatter plot, to see how bill depth and bill length relate to each other. # Next layer(s): geometric object(s) ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + # Use the plus sign to add each additional layer geom_point() # The geom layer determines what style of plot we are using. # geom_point() plots the data as points! Note that you can add several geoms in one plot. For example, we could add a line on this plot to show a threshold value, or add a linear regression. For now, let us keep it simple! 6.4.4 Facets, coordinates, and themes Now that the dataset is plotted, we can customize the plot to clarify the message, or to add more information. Facets are a popular way of dividing a plot into several windows according to some category in the data, to visually differentiate groupings. We can explore this plot differently if we use facet_wrap() to create separate ‚Äúfacets‚Äù according to our species groupings: # Next layer(s): customizations! Facets split a plot into # separate windows according to some category in the data. ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point() + facet_wrap(vars(species)) # This splits the plot into three windows: one per species Note: You could also use facet_grid() if you wanted to facet according to two variables. We can also adjust the scale of our axes in the plot itself, rather than transforming the data. Let us assume we are interested in looking at the relationship between the bill measurements on a \\(log_{10}\\) scale. ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point() + facet_wrap(vars(species)) + # this transforms the axes&#39; coordinates using log10() geom_point() geom_point() + facet_wrap(vars(species)) + # this transforms the axes&#39; coordinates using log10() + geom_point() + facet_wrap(vars(species)) + # this transforms the axes&#39; coordinates using log10() facet_wrap(vars(species)) geom_point() + facet_wrap(vars(species)) + # this transforms the axes&#39; coordinates using log10() + geom_point() + facet_wrap(vars(species)) + # this transforms the axes&#39; coordinates using log10() # geom_point() + facet_wrap(vars(species)) + # this transforms the axes&#39; coordinates using log10() this geom_point() + facet_wrap(vars(species)) + # this transforms the axes&#39; coordinates using log10() transforms geom_point() + facet_wrap(vars(species)) + # this transforms the axes&#39; coordinates using log10() the geom_point() + facet_wrap(vars(species)) + # this transforms the axes&#39; coordinates using log10() axes&#39; geom_point() + facet_wrap(vars(species)) + # this transforms the axes&#39; coordinates using log10() coordinates geom_point() + facet_wrap(vars(species)) + # this transforms the axes&#39; coordinates using log10() using geom_point() + facet_wrap(vars(species)) + # this transforms the axes&#39; coordinates using log10() log10() coord_trans(x = &quot;log10&quot;, y = &quot;log10&quot;) As a final touch, we can also customize the plot‚Äôs theme, which includes its background, grid lines, and other visual characteristics of the plot. Let us assume we do not like the default grey background from ggplot2 (we would not be alone in this!). We can use theme_bw() to produce a more visually appealing plot. We will discuss themes in Chapter 11! ggplot(data = penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point() + facet_wrap(vars(species)) + coord_trans(x = &quot;log10&quot;, y = &quot;log10&quot;) + # this uses a nicer theme for our final plot y y = &quot;log10&quot;) + # this uses a nicer theme for our final plot = y = &quot;log10&quot;) + # this uses a nicer theme for our final plot &quot;log10&quot;) y = &quot;log10&quot;) + # this uses a nicer theme for our final plot + y = &quot;log10&quot;) + # this uses a nicer theme for our final plot # y = &quot;log10&quot;) + # this uses a nicer theme for our final plot this y = &quot;log10&quot;) + # this uses a nicer theme for our final plot uses y = &quot;log10&quot;) + # this uses a nicer theme for our final plot a y = &quot;log10&quot;) + # this uses a nicer theme for our final plot nicer y = &quot;log10&quot;) + # this uses a nicer theme for our final plot theme y = &quot;log10&quot;) + # this uses a nicer theme for our final plot for y = &quot;log10&quot;) + # this uses a nicer theme for our final plot our y = &quot;log10&quot;) + # this uses a nicer theme for our final plot final y = &quot;log10&quot;) + # this uses a nicer theme for our final plot plot theme_bw() 6.5 Challenge 1 Now it‚Äôs time to try to build your own plot! Make a ggplot to answer the following questions: 1. Is there a relationship between bill length &amp; flipper length? 2. Does bill length increase with flipper length? Here are some parameters to consider when addressing this question: data geom x value y value penguins geom_point bill_length_mm flipper_length_mm 6.5.1 Challenge 1: Solution Let‚Äôs create a scatter plot with bill length on the x-axis and flipper length on the y-axis, to visualize the relationship between these two variables. # Make a scatter plot to visualize the variables ggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm)) + geom_point() Aesthetics can either be in the ggplot() line, and will be inherited by every geom, or in the geom_() line to apply to that geom only. Here is an example. # Customize the points&#39; shape and colour ggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm)) + geom_point(shape = 2, color = &quot;blue&quot;) Colour, alpha (transparency), shape, and size commands can be set outside of aes() values, and will be static, not data-dependent. Here, blue is not conveying any information in the data - it is just a choice we have made to make a prettier plot. This plot does appear to show a positive relationship between bill length and flipper length across all the measured individuals in the dataset. So, penguins with longer bills tend to have longer flippers too. We can keep digging into this relationship by building on this plot! References "],["aesthetics.html", "Chapter 7 Aesthetics", " Chapter 7 Aesthetics Let‚Äôs talk more about the aesthetic layer, this is where we can get really creative with our data! We can use aesthetics (aes()) to distinguish classes, groups and structure. In this section, we will talk about colour, shape, size, labels and transparency so that you can make your plots look exactly how you imagined them. Figure 7.1: Aesthetics allow us to represent many dimensions of our dataset in one plot by varying colour, shape, size, labels and transparency. "],["colours-make-your-points-talk.html", "Chapter 8 Colours: make your points talk 8.1 Using aes() use to change colour 8.2 Manual colour change 8.3 Gradients 8.4 Use a new colour palette 8.5 Colourblind-friendly palettes", " Chapter 8 Colours: make your points talk When we are designed plots, we may want to change the colour of our data points in order to communicate different parts of the data. We may want to: Differentiate between groups Represent data values Highlight specific elements of the data Reference: Fundamentals of Data Visualization (Wilke 2019). 8.1 Using aes() use to change colour We can use the aesthetic layer aes() to map colours to our data in our plots. This will allow us to clearly communicate specific messages about our data. For instance, if we want to know whether bill length and flipper length vary differently across species, which of these plots allows us to answer that question? # No colour mapping ggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm)) + geom_point() + geom_smooth(method = lm) + labs(title = &quot;No colour mapping&quot;, x = &quot;Bill length (mm)&quot;, y = &quot;Bill depth (mm)&quot;) # With colour mapping ggplot(data = penguins, aes(x = bill_length_mm, y = flipper_length_mm, col = species)) + # Using the col argument, we can colour by species geom_point() + geom_smooth(method=lm) + labs(title = &quot;With colour mapping&quot;, x = &quot;Bill length (mm)&quot;, y = &quot;Bill depth (mm)&quot;) 8.2 Manual colour change In the above example, we used the col argument within aes() in order to colour our data points by species automatically. This is possible because aes() can call our data variables. However, this method will use a default colour palette. If we want to add specific colours to our plots, we can do it manually using scale_colour_manual() or scale_fill_manual(). # Default # Let ggplot assign colours to species pp &lt;- ggplot(data = penguins) + geom_point(aes(x = bill_length_mm, y = bill_depth_mm, colour = species)) + labs(title = &quot;Default&quot;, x = &quot;Bill length (mm)&quot;, y = &quot;Bill depth (mm)&quot;) pp # Manual colour change # By using scale_colour_manual(), # we can specify the exact colours we want to use pp + scale_colour_manual( # Note that the colour order will correspond to # the order of the species given in the legend values = c(&quot;grey55&quot;, &quot;orange&quot;, &quot;skyblue&quot;)) Here, we are saving our plot as an object (pp), and adding elements to this object with a + to change the scaling of the colour mapping. We do not need to rewrite the whole ggplot to customize it! 8.3 Gradients We can do the same thing with colour gradients using scale_colour_gradient() if we want to communicate something different about our data. In this example, we are colouring our data points by body mass using a gradient. # Default # Using the colour argument within aes() will use a default # colour palette to make our gradient pp2 &lt;- ggplot(data = penguins) + geom_point(aes(x = bill_length_mm, y = bill_depth_mm, colour = log10(body_mass_g))) + labs(title = &quot;Default&quot;, x = &quot;Bill length (mm)&quot;, y = &quot;Bill depth (mm)&quot;) pp2 # Manual # By using scale_colour_graduent, we can set our colour # gradient manually pp2 + scale_colour_gradient(low = &quot;blue&quot;, high = &quot;red&quot;) + labs(title = &quot;Manual&quot;) # Note: there is also scale_colour_gradient2() to create a # gradient with a midpoint value for diverging palettes 8.4 Use a new colour palette If you prefer to use a pre-set colour palette rather than setting your colours manually, but you do not want to use the default palette - don‚Äôt worry! There are a lot of options for you. There are many R colour packages specifically designed to provide you with a range of colour palette options that all strike a different mood! For example, the RColorBrewer package have 35 palettes to choose from! Here you can see they are organized into different groups depending on whether the colours are sequential, diverging or a mixture of the two. You can imagine that different palettes are better for different data types. require(RColorBrewer) display.brewer.all() Want to see these palettes in action? Here is an example of the Dark2 palette being used to group data points with the scale_colour_brewer() function and the palette arguemnt. # Palette for groups pp + scale_colour_brewer(palette = &quot;Dark2&quot;) + labs(title = &quot;Palette for groups&quot;) There are other functions within the RColorBrewer package as well. By using scale_color_viridis(), we can use a default package that will translate from colour to gray scale without losing information. (Note that this is also an important consideration for colourblindness, which we will discuss soon). # Palette for continuous values pp2 + scale_color_viridis_c() + labs(title = &quot;Palette for continuous values&quot;) Now what if we want to use just gray-scale palette for publication purposes? We can use the scale_colour_grey() function to colour our grouped data points. # Palette for groups pp + scale_colour_grey() + labs(title = &quot;Palette for groups&quot;) Or we can use the scale_colour_gradient() function for continuous data, and set our low and high gradient points to black and light gray. # Palette for continuous values pp2 + scale_colour_gradient(low = &quot;grey85&quot;, high = &quot;black&quot;) + labs(title = &quot;Palette for continuous values&quot;) 8.5 Colourblind-friendly palettes Have you ever considered how your figure might appear under various forms of colourblindness? We can use the package colorblindr to consider this. This package is not currently on CRAN, so we install it with the packages remotes. # Let&#39;s install the colorblindr package from GitHub using # remotes install.packages(&quot;remotes&quot;, quiet = TRUE) remotes::install_github(&quot;clauswilke/colorblindr@cc54c8a35f8e7689ef4cc128b0da3af92f8cd540&quot;, quiet = TRUE) library(colorblindr) Let‚Äôs start by testing out some colours using the cvd_grid() function. This will show us how our current plot looks for different forms of colourblindness. cvd_grid(pp) # Let&#39;s check how our plot looks with different forms of colourblindness As you can see, our current colour palette is not accessible! By using viridis palettes, we can guarantee our plots always communicate the same information no matter who the audience is. 8.5.1 Example for grouped data Here is an example with grouped data points: # Let&#39;s use a viridis palette to make our plot more # accessible pp_viridis &lt;- pp + scale_colour_viridis_d() + labs(title = &quot;Viridis palette for groups&quot;) pp_viridis # Did we succeed? Let&#39;d use cvd_grid() to check again cvd_grid(pp_viridis) # We succeeded! 8.5.2 Example for continuous data Note that we are using slightly different functions for different colours (ex. scale_colour_viridis_c(), scale_colour_viridis_d()) pp2_viridis &lt;- pp2 + scale_colour_viridis_c() + labs(title = &quot;Viridis palette for continuous values&quot;) pp2_viridis cvd_grid(pp2_viridis) References "],["changing-shape-size-and-alpha.html", "Chapter 9 Changing shape, size and alpha 9.1 Challenge 2", " Chapter 9 Changing shape, size and alpha Now let‚Äôs look beyond colour! If we want to change the shape of our data points, we can start by using the shape argument within the aes() layer just like we did with colour. This will group our data points by the variable we provide using different shapes (here we are using the variable species). If we want to adjust the size of the data points instead, we can use the size argument in the same spot. We can also use the alpha argument if we want to play with transparency. Both of these are good options for continuous data. # shape for groups ggplot(data = penguins) + geom_point(aes(x = bill_length_mm, y = bill_depth_mm, shape = species)) + # Group data with data point shape labs(title = &quot;Shapes for groups&quot;) # size and alpha for continuous values ggplot(data = penguins) + geom_point(aes(x = bill_length_mm, y = bill_depth_mm, size = body_mass_g,# Group data using point size alpha = flipper_length_mm)) + # Group data using transparency labs(title = &quot;Size and alpha for continuous values&quot;) You may have noted in the second plot that you can even combine multiple of these options at once! But, setting many variables to visual cues like color, shape, size, and alpha at once tends to be overwhelming for the viewer. Adding 4 levels of complexity on top of the 2-dimensional representation of points can be too much to process properly. It is preferable to choose the visual cues and key variables for the desired message than to overload a plot with every possibility in the aes() function. 9.1 Challenge 2 Produce an informative plot from built-in datasets such as mtcars, CO2 or msleep. Use appropriate aesthetic mappings for different data types! Data x y Aesthetics mtcars wt mpg disp and hp CO2 conc uptake Treatment and Type msleep log10(bodywt) awake vore and conservation ToothGrowth dose len supp Pay attention to the data types! 9.1.1 Challenge 2: Solution (mtcars) There are multiple ways to respond to this challenge. Here is one example using the mtcars dataset: Data x y Aesthetics mtcars wt mpg disp and hp # One of many solutions: mtcars data(mtcars) ggplot(data = mtcars) + geom_point(aes(x = wt, y = mpg, colour = disp, alpha = hp)) Could you use size instead of alpha? What about shape? 9.1.2 Challenge 2: Solution (CO2) Here is a second example using the CO2 dataset: Data x y Aesthetics CO2 conc uptake Treatment and Type # Another possible solution data(CO2) ggplot(data = CO2) + geom_point(aes(x = conc, y = uptake, colour = Treatment, shape = Type)) 9.1.3 Challenge 2: Solution (msleep) Here is a third example using the msleep dataset: Data x y Aesthetics msleep log10(bodywt) awake vore and conservation # Another possible solution data(msleep) ggplot(data = msleep) + geom_point(aes(x = log10(bodywt), y = awake, colour = vore, shape = conservation)) 9.1.4 Challenge 2: Solution (ToothGrowth) Here is a final example using the ToothGrowth dataset: Data x y Aesthetics ToothGrowth dose len supp data(ToothGrowth) ggplot(ToothGrowth, aes(x = dose, y = len, color = supp)) + geom_point() + geom_smooth(method = lm, formula = &quot;y ~ x&quot;) "],["changing-the-scale-of-the-axes.html", "Chapter 10 Changing the scale of the axes", " Chapter 10 Changing the scale of the axes We can also adjust the scale of our axes using the coord_trans() function. Sometimes transforming our axes is necessary to show certain relationships within our data. A common example is a log transformation with log10(). Let us compare an example with an untransformed axes, followed by \\(log_{10}\\)-transformed axes. Example A: x axis on the original (untransformed) scale ggplot(diamonds) + geom_point(aes(x = carat, y = price)) + labs(title = &quot;Original scale&quot;) Example B: x-axis and y-axis in \\(log_{10}\\) scale ggplot(diamonds) + geom_point(mapping = aes(x = carat, y = price)) + coord_trans(x = &quot;log10&quot;, y = &quot;log10&quot;) + labs(title = &quot;log10 scale&quot;) It is also possible to transform the coordinate system using scale_x_log10() and scale_y_log10(). "],["theme.html", "Chapter 11 Using theme() to make it look good! 11.1 Introduction to themes 11.2 Elements of a theme 11.3 Building your own theme 11.4 More themes", " Chapter 11 Using theme() to make it look good! 11.1 Introduction to themes This presentation has been using theme_classic() for the plots, because the grey background can make certain colours harder to see. These are good options for publishing figures. But, like every other part of the grammar of graphics, we can modify the theme of the plot to suit our needs, or higher sense of style! There are way too many theme elements built into the ggplot2 package to mention here, but you can find a complete list in the ggplot theme vignette. Instead of modifying the many elements contained in theme(), you can start from theme functions, which contain a specific set of elements from which to start. Here are some examples: 11.1.1 Default: Grey # Theme grey pp + scale_colour_grey() + # Make data points gray theme_grey() + # Make background gray labs(title = &quot;Default: Grey&quot;) # Title plot 11.1.2 Theme Classic pp + scale_colour_grey() +# Make data points gray theme_classic() + # Make background white labs(title = &quot;Classic&quot;) # Title plot 11.1.3 Theme Minimal pp + scale_colour_grey() + theme_minimal() + # Make background white with gray gridlines labs(title = &quot;Minimal&quot;) 11.1.4 Setting the theme across all plots As you may have noticed, ggplot code can quickly become long when you constantly need to specify the characteristics of the theme you want to use. When you are making multiple plots and want them to all have the same theme, you can simple use theme_set() to set the theme for all plots that are generated afterwards, or theme_update() to edit elements of an existing theme setting without rewriting all the other theme elements. 11.1.4.1 Setting a theme # Set black &amp; white theme as default theme_set(theme_bw()) # Note the background is white with a black frame pp After using theme_set(), our pp plot is generated with the black &amp; white theme theme_bw(). Any future plots generated in your R session would also be generated with this theme. 11.1.4.2 Updating a theme Perhaps the minor gridlines are not necessary for this plot, though we like everything else about our theme. Rather than rewriting several lines of code to respecify the theme, we can simply use theme_update() to adjust a specific element of our theme. # remove minor gridlines theme_update(panel.grid.minor = element_blank()) # Adjust gridline scale pp There! Much better! 11.2 Elements of a theme Here is a helpful infographic to help you customize your theme to fit your exact needs! Figure 11.1: ggplot2 theme reference sheet by Isabella Benabaye (source). 11.3 Building your own theme Once you become more comfortable with customizing existing ggplot themes, you might want to think about creating your own theme to add to your plots. This is a great way to make your plots stand out in a presentation, a publication, a website, or wherever else they find a home! Here is an example: mytheme &lt;- theme_bw() + # You can start from an existing theme to get some of the basic elements set up theme(plot.title = element_text(colour = &quot;red&quot;)) + theme(legend.position = c(0.9, 0.9)) pp + mytheme # Apply it to your plot! 11.4 More themes The ggthemes package is a great project developed by Jeffrey Arnold on GitHub and also hosted on the CRAN repository. The package contains many themes, geoms, and colour ramps for ggplot2 which are based on the works of some of the most renown and influential names in the world of data visualization, from the classics such as Edward Tufte to the modern data journalists and programmers at FiveThirtyEight blog. The package can be installed as follows: install.packages(&quot;ggthemes&quot;) library(ggthemes) We can then apply some of these themes (and more) to our plot! # Let&#39;s use the FiveThirtyEight blog&#39;s theme, and Tableau&#39;s # color palette pp + theme_fivethirtyeight() + scale_color_tableau() # Let&#39;s use Tufte&#39;s &#39;Maximal Data, Minimal Ink&#39; theme pp + theme_tufte() "],["using-facets-to-split-up-your-plot.html", "Chapter 12 Using facets to split up your plot 12.1 Facetting by one variable 12.2 Facetting by two variables 12.3 Title and axes components: size, colour and face 12.4 Challenge 3", " Chapter 12 Using facets to split up your plot 12.1 Facetting by one variable ggplot(data = penguins) + geom_point(mapping = aes(x = bill_length_mm, y = bill_depth_mm, colour = species)) + facet_grid(~species, scales = &quot;free&quot;) # the scale of the y axis can vary between facets. # do not do this if you are comparing facets via the y # axis! 12.2 Facetting by two variables ggplot(data = penguins) + geom_point(mapping = aes(x = bill_length_mm, y = bill_depth_mm, colour = species)) + facet_grid(year ~ species, scales = &quot;free&quot;) 12.3 Title and axes components: size, colour and face Let us come back to our default plot that we have been building on. # our default plot from before pp We can tune the axes and titles to make the information clearer, so the plot can speak for itself. 12.4 Challenge 3 Use the tips dataset found in reshape2 üì¶ to reproduce the plot below. # install and load the package install.packages(&quot;reshape2&quot;) ## Installing package into &#39;/home/runner/work/_temp/Library&#39; ## (as &#39;lib&#39; is unspecified) library(reshape2) Our tip: Go step by step! When fine-tuning your plot, start from theme_classic() and add theme() to make your additional changes. 12.4.1 Challenge 3: Solution # Build the plot tips.gg &lt;- ggplot(tips, # Step 1. Specify the aesthetic mapping from the axes and the legends aes(x = total_bill, y = tip/total_bill, shape = smoker, colour = sex, size = size)) + # Step 2. Specify the geom used to represent the data geom_point() + # Step 3. Specify the variable used to make facets facet_grid( ~ time) + # Step 4. set the colour scale used to represent sex scale_colour_grey() + # Step 5. Label the plot title and axes labs(title = &quot;Relation between total bill and tips during lunch and dinner&quot;, x = &quot;Total bill ($)&quot;, y = &quot;Ratio between tips and total bill&quot;) + # Step 6. Set the theme theme_classic() + # Step 7. Customise the theme to match the sizing and colour of the plot labels theme(axis.title = element_text(size = 16, colour = &quot;navy&quot;), axis.text = element_text(size = 12), plot.title = element_text(size = 16, colour = &quot;orange3&quot;, face = &quot;bold&quot;), # this part adjusts the text in the facet labels (strips!) strip.text.x = element_text(size = 14, face=&quot;bold&quot;)) # print our beautiful plot! tips.gg "],["using-geom_-to-create-different-plots.html", "Chapter 13 Using geom_*() to create different plots 13.1 Histograms: geom_histogram() 13.2 Scatterplot and linear-fit: geom_point() and geom_smooth() 13.3 Boxplot: geom_boxplot() 13.4 Annotated boxplot: geom_boxplot() and geom_signif() 13.5 Violin plot: geom_violin() 13.6 Summarise y values: stat_summary() 13.7 Representing maps: geom_map() 13.8 Density plots: geom_density() 13.9 Dendogram: ggdendrogram() 13.10 Arrange plots: patchwork 13.11 Challenge 4 13.12 Miscellaneous: interactive plots using plotly()", " Chapter 13 Using geom_*() to create different plots Multiple geoms can be used together in a single plot! The order determines how they overlap. This is a blank plot, before we add any geom_* to represent variables in the dataset. ggplot(penguins) 13.1 Histograms: geom_histogram() A histogram is an accurate graphical representation of the distribution of numeric data. There is only one aesthetic required: the x variable. ggplot(penguins, aes(x = bill_length_mm)) + geom_histogram() + ggtitle(&quot;Histogram of penguin bill length &quot;) 13.2 Scatterplot and linear-fit: geom_point() and geom_smooth() A scatter plot is a great way to visualize data points for two variables. Two aesthetics are required in geom_point(): the x and y variables. ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + labs(title = &quot;Scatterplot&quot;) It can, however, be difficult to discern any potential relationship in a scatter plot. You can use geom_smooth() to fit a line through your data with a variety of methods. Here, we will add a linear fit to the scatter plot. ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + geom_smooth(method = lm) + labs(title = &quot;Linear Regression&quot;) 13.3 Boxplot: geom_boxplot() Boxplots are a popular way to plot the distribution of data across some grouping variable, like species. You can specify this grouping variable in aes() using group =, or the aesthetics used to represent the data (fill =, col =, shape =) to generate the boxplot. ggplot(data = penguins, aes(x = species, y = bill_length_mm, fill = species)) + # specify species as a grouping variable geom_boxplot() + labs(title = &quot;Boxplot&quot;) Though boxplots are very popular to summarise data, someone looking at your plot may not intuitively grasp how this summary works and what it might be hiding. Using boxplots well requires an understanding of their anatomy, as seen below. More on the pitfalls of boxplots here. Figure 13.1: Anatomy of a boxplot by Denise Coleman. 13.4 Annotated boxplot: geom_boxplot() and geom_signif() To help boxplots speak for themselves, we can add annotations with geom_signif(). The function geom_signif() calculates the significance of a difference between groups and adds the annotation to the plot in a single line. library(ggsignif) ggplot(data = penguins, aes(x = species, y= bill_length_mm, fill = species)) + geom_boxplot() + geom_signif( # which groups should be compared? comparisons = list(c(&quot;Adelie&quot;, &quot;Gentoo&quot;)), map_signif_level=TRUE) 13.5 Violin plot: geom_violin() Like boxplots, violin plots visualise the distribution of a numeric variable for one or several groups. However, a violin‚Äôs shape represents the distribution of points that is obscured in a boxplot‚Äôs summarisation, allowing for a more accurate representation of the data (Data-to-Viz)). Let us compare a boxplot and a violin plot on some generated data. Notice how the violin plot shows us the range and the variability in our data, while the boxplot cannot communicate these two things as intuitively. We can make a violin plot with our penguins data: violin &lt;- ggplot(data = penguins, aes(x = species, y = bill_length_mm)) + geom_violin(trim = FALSE, # do not trim the violins&#39; tips if there are outliers fill = &quot;grey70&quot;, # set all the violins to grey alpha = .5) + # transparency of the fill colour labs(title = &quot;Violin plot&quot;) violin Although we have a good idea of how the data is distributed, we can enhance the plot by visualising some summary statistics and the data points. Let us plot a boxplot and the data points on top of our violin plot with geom_violin() + geom_boxplot() + geom_jitter(). violin + # this plots the data points with some additional (horizontal) noise to see overlapping points violin violin + # this plots the data points with some additional (horizontal) noise to see overlapping points + violin + # this plots the data points with some additional (horizontal) noise to see overlapping points # violin + # this plots the data points with some additional (horizontal) noise to see overlapping points this violin + # this plots the data points with some additional (horizontal) noise to see overlapping points plots violin + # this plots the data points with some additional (horizontal) noise to see overlapping points the violin + # this plots the data points with some additional (horizontal) noise to see overlapping points data violin + # this plots the data points with some additional (horizontal) noise to see overlapping points points violin + # this plots the data points with some additional (horizontal) noise to see overlapping points with violin + # this plots the data points with some additional (horizontal) noise to see overlapping points some violin + # this plots the data points with some additional (horizontal) noise to see overlapping points additional violin + # this plots the data points with some additional (horizontal) noise to see overlapping points (horizontal) violin + # this plots the data points with some additional (horizontal) noise to see overlapping points noise violin + # this plots the data points with some additional (horizontal) noise to see overlapping points to violin + # this plots the data points with some additional (horizontal) noise to see overlapping points see violin + # this plots the data points with some additional (horizontal) noise to see overlapping points overlapping violin + # this plots the data points with some additional (horizontal) noise to see overlapping points points geom_jitter(shape = 16, position = position_jitter(0.2), alpha = 0.3) + geom_boxplot(width = 0.05) 13.6 Summarise y values: stat_summary() Adding summary statistics to your plot can help to highlight the key message in your plot. The function stat_summary() can run the summary statistic of your choice using the argument fun =, and add it to your plot according to the geom = you have set in the function. For example, if we wanted to plot the median of the number of cylinders (cyl) in the mtcars dataset, we would use stat_summary() in the following way: # plot the median of the number of cylinders ggplot(mtcars, aes(x = cyl, y = mpg)) + geom_point() + stat_summary(fun = &quot;median&quot;, geom = &quot;point&quot;, colour = &quot;red&quot;, size = 6) + labs(title = &quot;Medians&quot;) Though the median is a helpful summary statistics, it does not inform us about the uncertainty behind it. If we wanted to instead plot the mean of each group with bootstrapped confidence intervals, we could just switch the fun.y = argument: # plot the mean of each group with bootstrapped confidence # intervals ggplot(mtcars, aes(cyl, mpg)) + geom_point() + stat_summary(fun.data = &quot;mean_cl_boot&quot;, colour = &quot;red&quot;, size = 1.6) + labs(title = &quot;Means and confidence intervals&quot;) ## Warning: Computation failed in `stat_summary()`: ## The `Hmisc` package is required. For more summary statistics, see geom_errorbar(), geom_pointrange(), geom_linerange(), geom_crossbar(). 13.7 Representing maps: geom_map() We will visualize arrests per 100,000 residents for murder in each of the 50 US states in 1973 from the USArrests dataset as a map using geom_map(). # load maps library library(maps) states_map &lt;- map_data(&quot;state&quot;) # get a state-level map of the US # State name is set as rownames. Let&#39;s make a new column for these # that matches the column of state names in our states_map USArrests$region &lt;- tolower(rownames(USArrests)) # Build our map ggplot(USArrests, aes(map_id = region)) + # the variable name to link our map and dataframe geom_map(aes(fill = Murder), # variable we want to represent with an aesthetic map = states_map) + # data frame that contains coordinates expand_limits(x = states_map$long, y = states_map$lat) + coord_map() + # projection labs(x = &quot;&quot;, y = &quot;&quot;) # remove axis labels 13.8 Density plots: geom_density() A density plot shows the distribution of a numerical variable and it takes only set of numeric values as input. (peng.dens &lt;- ggplot(penguins, aes(x = bill_length_mm)) + geom_density()) (cars.dens &lt;- ggplot(cars, aes(x = dist)) + geom_density()) 13.9 Dendogram: ggdendrogram() Which US states have similar arrest rates? library(ggdendro) USArrests.short &lt;- USArrests[1:10, ] # take a small sample for simplicity hc &lt;- hclust(dist(USArrests.short), &quot;average&quot;) # cluster by average distance (UPGMA) ## Warning in dist(USArrests.short): NAs introduced by coercion # plot the clustering dendrogram ggdendrogram(hc, rotate = TRUE) 13.10 Arrange plots: patchwork So far, we have used facets to split our plot into multiple windows. However, this is restricted to plotting the same variables from the same dataset. The patchwork package makes it easy to arrange separate ggplots together in one frame with + (arrange plots beside each other), / (arrange one plot on top of the other), () (group this arrangement of plots) as though you are writing an equation. # load patchwork to arrange our density plots library(patchwork) # adding them together means &#39;place them beside each other&#39; peng.dens + cars.dens + plot_annotation(tag_levels = &quot;a&quot;) # adds a) and b) to your plots, to reference # in your figure captions. 13.11 Challenge 4 Create your own ggplot and follow these recommendations: * Dataset: any (recommended: use your dataset) * Explore a new geom_* and other plot elements (recall Chapter (???)/(#gg-layers)) Use the following links for tips and inspiration: ggplot2 Reference R Graph Gallery Data to Viz 13.11.1 Challenge 4: Solution example 1 data(msleep) ggplot(msleep, aes(x = vore, y = log10(brainwt), fill = vore)) + geom_violin() + geom_signif(comparisons = list(c(&quot;herbi&quot;, &quot;insecti&quot;))) + labs(main = &quot;Brain weight among different vore&quot;, y = &quot;log10(Brain weight (Kg))&quot;) + scale_fill_grey() + theme_classic() 13.11.2 Challenge 4: Solution example 2 data(mtcars) # let&#39;s do some clustering! mtcars.short &lt;- mtcars[1:20, ] mtcars.short.hc &lt;- hclust(dist(mtcars.short), &quot;average&quot;) ggdendrogram(mtcars.short.hc, rotate = TRUE) + # fine-tuning ggdendrogram(mtcars.short.hc, ggdendrogram(mtcars.short.hc, rotate = TRUE) + # fine-tuning rotate ggdendrogram(mtcars.short.hc, rotate = TRUE) + # fine-tuning = ggdendrogram(mtcars.short.hc, rotate = TRUE) + # fine-tuning TRUE) ggdendrogram(mtcars.short.hc, rotate = TRUE) + # fine-tuning + ggdendrogram(mtcars.short.hc, rotate = TRUE) + # fine-tuning # ggdendrogram(mtcars.short.hc, rotate = TRUE) + # fine-tuning fine-tuning labs(title = &quot;Car dendro from motor spec&quot;, y = &quot;Cars&quot;) + theme(axis.title.y = element_text(size = 16), axis.text.y = element_text(size = 12), axis.title.x = element_blank(), axis.text.x = element_blank(), plot.title = element_text(size = 14, face = &quot;bold&quot;)) 13.12 Miscellaneous: interactive plots using plotly() The plotly() library contains the function ggplotly(), which translates your ggplot code into an interactive plotly object in one line of code. You can click on the species in the legend to add/remove species. You can also see values while hovering over points. library(plotly) p &lt;- ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, colour = species, shape = species)) + geom_point(size = 6, alpha = 0.6) # convert to a plotly object! ggplotly(p) "],["saving-your-plots-in-code.html", "Chapter 14 Saving your plots in code", " Chapter 14 Saving your plots in code In RStudio, there are many options available to you to save your figures. You could copy them to the clipboard, but it is preferable to export them as a file type of your choice (or export them as any file type (png, jpg, emf, tiff, pdf, metafile, etc). ggsave() is a useful command that saves directly to your working directory and allows you to specify the name of your new file, the dimensions of the plot, the resolution, etc. my1stPlot &lt;- # Create a plot to practice saving ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point() ggsave(filename = &quot;my1stPlot.pdf&quot;, # Name the file you want to save to, add extension of the file format you want to use (ex. pdf) plot = my1stPlot, # Provide the name of the plot object in RStudio height = 8.5, # Provide any addition information width = 11, units = &quot;in&quot;) # Tip:`quartz()` (mac) or `window()` (pc) functions make sizing easier before `ggsave()`! # Just plot your ggplot in quartz() or window(), adjust the size until it looks good, # and run ggsave() with the filename to see which dimensions you used! You can # then add this in your code with height = and width = as shown above. Think about the margin of the document you are using. If you resize the image after saving it, the labels and text will change size as well which could be hard to read. Also note that vector format (e.g., pdf, svg) is more flexible than raster format (jpeg, png, ‚Ä¶) if the image needs modification afterwards. If you prefer raster format, you can check out other methods to save image using ?pdf ?jpeg. In instances where you are producing many plots (e.g.¬†during long programs that produces many plots automatically while performing analysis), it is useful to save many plots in one file as a pdf. This can be accomplished as follows: my2ndPlot &lt;- # Create a 2nd plot to practice saving ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) + geom_point() pdf(&quot;./graph_du_jour.pdf&quot;) print(my1stPlot) # print function is necessary print(my2ndPlot) graphics.off() "],["concluding-remarks.html", "Chapter 15 Concluding remarks", " Chapter 15 Concluding remarks There are other useful packages that can be used with ggplot2! To name a few: ggbio, ggpmisc, geomnet, gganimate, ggnetwork and ggtree. Have a look at www.ggplot2-exts.org for other ggplot2 extensions. Note that you can learn more about design and image manipulation with the QCBS workshop ‚ÄúIntroduction to graphic design and image manipulation with open source tools‚Äù. "],["additional-resources.html", "Chapter 16 Additional resources 16.1 Reference documents 16.2 Books 16.3 Inspiration and guides 16.4 Lecture notes", " Chapter 16 Additional resources 16.1 Reference documents help(package = ggplot2) Data Visualization with ggplot2 Cheat Sheet ggplot2 Reference 16.2 Books Fundamentals of Data Visualization 16.3 Inspiration and guides From Data to Viz A Compendium of Clean Graphs in R (base R) Graphics Principles (design tips) The R Graph gallery 16.4 Lecture notes Lecture notes from Hadley‚Äôs course Stat 405 (the other lessons are awesome too!) http://stat405.had.co.nz/lectures/11-adv-data-manip.pdf http://stat405.had.co.nz/lectures/19-tables.pdf "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
